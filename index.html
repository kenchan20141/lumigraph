<!DOCTYPE html>
<html lang="zh">
<head>
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-512.png">
<meta name="theme-color" content="#000000">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Lumigraph</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@600&display=swap" rel="stylesheet">
    
<style>
    /* [樣式保持不變，為了節省篇幅，直接沿用原本的 CSS] */
    :root {
        --leather-color: #151515;
        --metal-grad: linear-gradient(to bottom, #f0f0f0 0%, #d0d0d0 15%, #b0b0b0 40%, #8a8a8a 100%);
        --shutter-grey: linear-gradient(to bottom, #e0e0e0, #999);
    }

    * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; user-select: none; }
   
    html, body { width: 100%; height: 100%; margin: 0; padding: 0; background-color: #000; display: block; position: fixed; top: 0; left: 0; overflow: hidden; font-family: 'Arial', sans-serif; color: #333; perspective: 1200px; }
    
    #fullscreen-prompt, #orientation-lock { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; text-align: center; }
    #orientation-lock { display: none; background: #111; z-index: 9999; }
    #enter-fs-btn { padding: 15px 30px; background: #c00; color: white; border: 1px solid #fff; font-family: 'Courier New', monospace; font-size: 18px; cursor: pointer; animation: pulseBtn 2s infinite; margin-top: 20px; }
    @keyframes pulseBtn { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }
    #orientation-lock svg { width: 60px; height: 60px; fill: #fff; animation: rotatePhone 2s infinite; }
    @keyframes rotatePhone { 0%, 100% { transform: rotate(0deg); } 50% { transform: rotate(-90deg); } }

   #camera-container { width: 760px; height: 420px; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); transform-origin: center center; filter: drop-shadow(0 0 2px rgba(255,255,255,0.25)) drop-shadow(0 30px 60px rgba(0,0,0,0.9)); display: none; transform-style: preserve-3d; z-index: 100; contain: layout size; }

    /* [用此版本完整替換舊的 .top-plate 規則] */

.top-plate { 
    width: 100%; 
    height: 110px; 
    background: var(--metal-grad); 
    border-radius: 12px 12px 2px 2px; 
    position: relative; 
    z-index: 10; 
    border: 1px solid rgba(255,255,255,0.2); 
    border-bottom: 1px solid #555; 
    
    /* [核心修改] 使用多層次的內外陰影來打造精緻的金屬邊緣質感 */
    box-shadow: 
        /* 1. 頂部邊緣的內側高光，模擬金屬反光 */
        inset 0 1px 1px rgba(255,255,255,0.7),
        /* 2. 底部邊緣的深色線條，強化與機身的分割線 */
        0 1px 0 #555;
}
   /* [修改] 機頂取景器外框 */
.viewfinder-wrap { 
    position: absolute; 
    top: 15px; 
    left: 30px; 
    width: 120px; 
    height: 80px; 
    background: #000; /* 內部改為全黑，模擬暗箱 */
    border: 4px solid #444; /* 加粗邊框，模擬金屬框 */
    border-radius: 4px; 
    box-shadow: 
        0 2px 5px rgba(0,0,0,0.5), /* 外部陰影 */
        inset 0 0 0 1px rgba(0,0,0,1); /* 邊框與機身的接縫 */
    overflow: hidden; 
    cursor: zoom-in; 
    z-index: 12; 
    transition: opacity 0.3s; 
}

/* [新增] 這是「玻璃質感」的關鍵：反光層與內陰影 */
.viewfinder-wrap::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 20; /* 確保覆蓋在 Canvas 之上 */
    pointer-events: none; /* 讓點擊事件可以穿透玻璃傳給 Canvas */
    
    /* 1. 內陰影：讓玻璃看起來凹陷 */
    box-shadow: inset 0 0 15px rgba(0,0,0,0.8); 
    
    /* 2. 複雜的漸層：模擬弧形玻璃反光 + 鍍膜色澤 */
    background: 
        /* 左上角的強烈反光 (高光) */
        linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.05) 20%, transparent 21%, transparent 100%),
        /* 整體的微妙青色鍍膜反光 */
        radial-gradient(circle at 50% 120%, rgba(100, 200, 255, 0.1), transparent 60%);
}

/* [修改] 內部的 Canvas 畫面 */
.vf-glass { 
    width: 100%; 
    height: 100%; 
    opacity: 0.85; /* 稍微降低不透明度，讓它融入黑色背景 */
    display: block; 
    filter: contrast(1.1) brightness(0.9); /* 模擬從光學取景器看出去稍微暗一點的感覺 */
}
    .function-group { position: absolute; top: 18px; left: 170px; width: 100px; height: 80px; display: flex; flex-direction: column; gap: 12px; z-index: 25; }
    .top-row-btns { display: flex; gap: 12px; align-items: center; }
    .flat-lock-btn { width: 50px; height: 26px; background: linear-gradient(to bottom, #e0e0e0, #bbb); border: 1px solid #888; border-radius: 2px; box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8); display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; }
    .flat-lock-btn:active { background: #bbb; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); transform: translateY(1px); }
    .flat-lock-btn span { font-family: sans-serif; font-size: 9px; font-weight: bold; color: #555; letter-spacing: 1px; transition: all 0.2s; }
    .flat-lock-btn.locked { background: #333; border-color: #000; box-shadow: inset 0 0 5px #000; }
    .flat-lock-btn.locked span { color: #ff9900; text-shadow: 0 0 5px rgba(255, 153, 0, 0.8); }
    .selfie-btn { width: 26px; height: 26px; background: radial-gradient(#ddd, #999); border: 1px solid #777; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.4); display: flex; justify-content: center; align-items: center; z-index: 30; }
    .selfie-btn::after { content: '↻'; font-size: 14px; font-weight: bold; color: #333; transition: transform 0.3s; }
    .selfie-btn:active::after { transform: rotate(180deg); }
    .compact-switch-container { display: flex; align-items: center; justify-content: center; gap: 8px; background: rgba(0,0,0,0.05); padding: 4px 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); cursor: pointer; }
    .cs-label { font-size: 9px; font-weight: bold; color: #555; font-family: sans-serif; }
    .cs-label.active { color: #000; }
    .cs-track { width: 30px; height: 8px; background: #333; border-radius: 4px; position: relative; box-shadow: inset 0 1px 2px #000; }
    .cs-knob { width: 14px; height: 12px; background: repeating-linear-gradient(90deg, #ccc, #ccc 1px, #999 1px, #999 2px); border-radius: 2px; position: absolute; top: -2px; left: 0; box-shadow: 0 1px 2px rgba(0,0,0,0.5); border: 1px solid #555; transition: left 0.3s; }
    .compact-switch-container.mode-sketch .cs-knob { left: 16px; }

    body.is-selfie .viewfinder-wrap { display: none !important; }
    body.is-selfie .flat-lock-btn { display: none !important; }
    body.is-selfie .compact-switch-container { display: none !important; }

    .serial-number { position: absolute; top: 75px; left: 520px; font-size: 12px; letter-spacing: 1px; font-weight: bold; color: #444; text-shadow: 0 1px 0 rgba(255,255,255,0.6); font-family: 'Courier New', Courier, monospace; pointer-events: none; z-index: 15; }
    .shutter-release-btn { position: absolute; top: -12px; right: 55px; width: 46px; height: 18px; background: var(--shutter-grey); border-radius: 4px 4px 0 0; border: 1px solid #888; border-bottom: none; cursor: pointer; z-index: 5; box-shadow: inset 0 1px 2px rgba(255,255,255,0.8), 0 -2px 5px rgba(0,0,0,0.2); transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1); }
    .shutter-release-btn.pressed { transform: translateY(8px); transition: transform 0.05s ease-out; }
    .prism-hump { position: absolute; top: -15px; left: 50%; transform: translateX(-50%); width: 140px; height: 125px; z-index: 11; clip-path: polygon(25% 0%, 75% 0%, 100% 100%, 0% 100%); background: linear-gradient(to bottom, #d0d0d0 0%, #b0b0b0 50%, #808080 100%); box-shadow: inset 0 0 10px rgba(0,0,0,0.2); display: flex; justify-content: center; }
    .prism-hump::after { content: ''; width: 1px; height: 100%; background: rgba(0,0,0,0.1); }
    
    .lever-base { position: absolute; top: 35px; right: 100px; width: 50px; height: 50px; border-radius: 50%; background: radial-gradient(#ccc, #999); border: 1px solid #666; z-index: 5; box-shadow: inset 0 1px 2px rgba(255,255,255,0.5); transition: box-shadow 0.3s; }
    .lever-base.glow { box-shadow: 0 0 20px #ffaa00, inset 0 0 10px #ffcc00; border-color: #ffaa00; animation: glowPulse 0.8s infinite alternate; }
    @keyframes glowPulse { from { box-shadow: 0 0 15px #ffaa00, inset 0 0 5px #ffcc00; } to { box-shadow: 0 0 25px #ff5500, inset 0 0 12px #ffdd00; } }

    .advance-lever { position: absolute; top: 48px; right: 105px; width: 120px; height: 18px; background: linear-gradient(to right, #222, #444); border-radius: 4px; transform-origin: 110px 9px; transform: rotate(10deg); cursor: grab; box-shadow: 2px 2px 4px rgba(0,0,0,0.6); z-index: 6; display: flex; align-items: center; transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .lever-grip { width: 30px; height: 24px; background: #111; border-radius: 4px 0 0 4px; margin-left: -2px; box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2); }
    .right-controls { position: absolute; top: 20px; right: 20px; width: 60px; height: 80px; z-index: 15; display: flex; flex-direction: column; align-items: center; }
    .counter-window { width: 36px; height: 24px; background: #111; border: 1px solid #666; border-radius: 2px; margin-bottom: 10px; box-shadow: inset 0 0 5px #000; display: flex; justify-content: center; align-items: center; }
    .counter-digits { color: #ff9900; font-family: 'Courier New', monospace; font-weight: bold; font-size: 14px; text-shadow: 0 0 2px #ff5500; }
    .mode-switch-container { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
    .mode-labels { display: flex; gap: 15px; font-size: 10px; font-weight: bold; color: #444; margin-bottom: 2px; font-family: sans-serif; }
    .switch-track { width: 36px; height: 14px; background: #333; border-radius: 10px; position: relative; box-shadow: inset 0 1px 3px #000; }
    .switch-knob { width: 18px; height: 18px; background: radial-gradient(#eee, #999); border-radius: 50%; position: absolute; top: -2px; left: 0; box-shadow: 0 1px 2px rgba(0,0,0,0.5); border: 1px solid #666; transition: left 0.3s; }
    .mode-switch-container.mode-36 .switch-knob { left: 18px; }
    .ready-light { position: absolute; top: 20px; right: 165px; width: 8px; height: 8px; background: #300; border-radius: 50%; box-shadow: inset 0 0 2px #000; transition: background 0.3s; z-index: 15; }
    .ready-light.active { background: #f00; box-shadow: 0 0 8px #f00, inset 0 0 2px #fff; }

    .front-controls-group { display: none; } 
    .cable-release-container { position: absolute; top: -100px; left: 0; width: 100%; height: 150%; pointer-events: none; z-index: 30; overflow: visible; display: none; }
    body.is-selfie .cable-release-container { display: block; }
    .cable-plunger-wrapper { position: absolute; top: 320px; right: -90px; width: 60px; height: 120px; pointer-events: auto; cursor: pointer; display: flex; flex-direction: column; align-items: center; transform: rotate(-10deg); }
    .cable-button-head { width: 28px; height: 18px; background: radial-gradient(circle at 30% 30%, #ff3333, #aa0000); border-radius: 50% 50% 5px 5px; border: 1px solid #333; border-bottom: none; position: relative; z-index: 3; box-shadow: inset 0 2px 3px rgba(255,255,255,0.4); transition: transform 0.1s; }
    .cable-stem { width: 8px; height: 20px; background: linear-gradient(to right, #999, #eee, #777); border: 1px solid #555; margin-top: -2px; position: relative; z-index: 2; transition: height 0.1s, transform 0.1s; }
    .cable-disc { width: 46px; height: 12px; background: linear-gradient(to bottom, #ccc, #888); border-radius: 50%; border: 1px solid #444; margin-top: -2px; position: relative; z-index: 2; box-shadow: 0 3px 5px rgba(0,0,0,0.4); }
    .cable-grip-body { width: 16px; height: 70px; background: repeating-linear-gradient(45deg, #666, #666 2px, #888 2px, #888 4px); border: 1px solid #333; border-radius: 0 0 4px 4px; margin-top: -6px; position: relative; z-index: 1; box-shadow: 3px 3px 8px rgba(0,0,0,0.6); }
    .cable-plunger-wrapper.pressed .cable-button-head { transform: translateY(12px); }
    .cable-plunger-wrapper.pressed .cable-stem { height: 8px; transform: translateY(12px); }

    .front-viewfinder-frame { 
    position: absolute; 
    top: 15px; 
    right: 40px; 
    width: 90px; 
    height: 65px; 
    background: #000; 
    border: 3px solid #555; 
    border-radius: 4px; 
    
    /* 外部立體感 */
    box-shadow: 
        0 2px 4px rgba(0,0,0,0.4), 
        inset 0 0 0 1px rgba(0,0,0,1); 
        
    overflow: hidden; 
    cursor: zoom-in; 
    z-index: 16; 
}

/* [新增] 正面玻璃質感 */
.front-viewfinder-frame::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 20;
    pointer-events: none;
    
    /* 較深的內陰影 */
    box-shadow: inset 0 0 12px rgba(0,0,0,0.9);
    
    /* 正面看鏡頭通常會有紫色或琥珀色的鍍膜反光 */
    background: 
        /* 反光條紋 */
        linear-gradient(115deg, transparent 30%, rgba(255,255,255,0.15) 45%, rgba(255,255,255,0.05) 50%, transparent 55%),
        /* 鍍膜感 */
        radial-gradient(circle at 30% 30%, rgba(100, 0, 200, 0.1), transparent 70%);
}
    .front-vf-glass { width: 100%; height: 100%; transform: scaleX(-1); }
    .camera-body { width: 100%; height: 310px; position: relative; border-radius: 0 0 8px 8px; perspective: 1000px; transform-style: preserve-3d; }

    .back-lock { position: absolute; top: 40px; right: -12px; width: 12px; height: 40px; background: linear-gradient(to bottom, #444, #222); border: 1px solid #222; border-left: none; border-radius: 0 4px 4px 0; border-top: 1px solid #555; border-bottom: 1px solid #555; border-right: 1px solid #555; cursor: pointer; z-index: 20; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); display: flex; flex-direction: column; justify-content: center; align-items: center; }
    .back-lock::after { content: ''; width: 4px; height: 20px; background: #111; border-radius: 2px; }
    .back-lock:active { transform: translateX(2px); }

    .back-door-wrapper { width: 100%; height: 100%; position: absolute; top: 0; left: 0; transform-origin: left center; transform-style: preserve-3d; transition: transform 0.8s cubic-bezier(0.25, 1, 0.5, 1); z-index: 5; }
    .back-door-wrapper.open { transform: rotateY(-100deg); }
    /* --- 相機背面 --- */
.back-door-face { 
    width: 100%; height: 100%; 
    position: absolute; top: 0; left: 0; 
    border-radius: 0 0 8px 8px; 
    backface-visibility: hidden; 

    /* [核心修改] 使用多層背景來疊加紋理和光影 */
    background-image: 
        /* 第一層 (最頂)：SVG 皮革紋理 */
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='leather'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='4' stitchTiles='stitch' result='noise'/%3E%3CfeSpecularLighting in='noise' specularConstant='1.5' specularExponent='30' surfaceScale='4.0' lighting-color='%23eee'%3E%3CfeDistantLight azimuth='45' elevation='50'/%3E%3C/feSpecularLighting%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23leather)' opacity='0.5'/%3E%3C/svg%3E"),
        /* 第二層 (最底)：從上到下的整體光影漸變 */
        linear-gradient(to bottom, #282828, #151515);
    background-size: 140px 140px, auto;
    
    /* [核心修改] 使用多層內陰影來雕刻立體感 */
    box-shadow: 
        /* 1. (最關鍵) 頂部內陰影：模擬頂板投射在機身上的陰影 (環境光遮蔽) */
        inset 0 6px 8px -4px rgba(0,0,0,0.85),
        /* 2. 底部內高光：模擬光線勾勒底部邊緣 */
        inset 0 -1px 1px rgba(255,255,255,0.05);
}
    .back-door-interior { width: 100%; height: 100%; position: absolute; top: 0; left: 0; background: #1a1a1a; border-radius: 0 0 8px 8px; transform: rotateY(180deg); backface-visibility: hidden; box-shadow: inset 0 0 20px #000; display: flex; justify-content: center; align-items: center; border: 1px solid #333; }
    .pressure-plate { width: 90%; height: 80%; background: repeating-linear-gradient(90deg, #222, #222 20px, #111 20px, #111 22px); border: 2px solid #000; box-shadow: inset 0 0 10px #000; }
    /* --- 相機正面 --- */
.camera-front-face { 
    width: 100%; height: 100%; 
    position: absolute; top: 0; left: 0; z-index: 6; 
    border-radius: 0 0 8px 8px; 
    display: none; justify-content: center; align-items: center; 

    /* [核心修改] 應用與背面完全相同的光影和紋理效果 */
    background-image: 
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='leather'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='4' stitchTiles='stitch' result='noise'/%3E%3CfeSpecularLighting in='noise' specularConstant='1.5' specularExponent='30' surfaceScale='4.0' lighting-color='%23eee'%3E%3CfeDistantLight azimuth='45' elevation='50'/%3E%3C/feSpecularLighting%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23leather)' opacity='0.5'/%3E%3C/svg%3E"),
        linear-gradient(to bottom, #282828, #151515);
    background-size: 140px 140px, auto;
    box-shadow: 
        inset 0 6px 8px -4px rgba(0,0,0,0.85),
        inset 0 -1px 1px rgba(255,255,255,0.05);
}
    .realistic-lens { width: 220px; height: 220px; border-radius: 50%; background: linear-gradient(135deg, #333 0%, #111 100%); border: 4px solid #222; box-shadow: 0 10px 25px rgba(0,0,0,0.8), inset 0 2px 5px rgba(255,255,255,0.1); display: flex; justify-content: center; align-items: center; position: relative; }
    .lens-barrel { width: 200px; height: 200px; border-radius: 50%; border: 8px solid #111; background: #000; display: flex; justify-content: center; align-items: center; position: relative; }
    .lens-glass-element {
    width: 160px;
    height: 160px;
    border-radius: 50%;

    /* 1. 核心光學質感：模擬鏡頭鍍膜的深紫色/深藍色漸層，而非純黑 */
    /* circle at 60% 40% 讓光點稍微偏右上，製造球體凸出的錯覺 */
    background: radial-gradient(circle at 60% 40%, #2a1b3e 0%, #0d0518 45%, #000000 85%);

    position: relative;
    overflow: hidden; /* 確保內部的快門葉片與反光不會溢出 */

    /* 2. 物理深度與玻璃厚度 */
    box-shadow: 
        /* 最深層的內陰影：模擬鏡桶深處的暗度 */
        inset 0 0 40px rgba(0,0,0,0.95),
        
        /* 左上邊緣的高光：模擬玻璃凸起的邊緣受光 */
        inset 3px 3px 6px rgba(255,255,255,0.15),
        
        /* 右下邊緣的微光：勾勒出玻璃的輪廓 */
        inset -2px -2px 5px rgba(255,255,255,0.05);

    /* 確保這層在鏡筒之上，但在反光層之下 */
    z-index: 10; 
}
    .lens-glass-element::before { content: ''; position: absolute; top: -30%; left: -30%; width: 160%; height: 160%; background: radial-gradient(circle at 35% 35%, rgba(138, 43, 226, 0.25) 0%, transparent 50%); filter: blur(8px); pointer-events: none; }
    .lens-reflection { position: absolute; top: 25%; left: 25%; width: 30px; height: 15px; background: rgba(255,255,255,0.3); border-radius: 50%; transform: rotate(-45deg); filter: blur(4px); pointer-events: none; z-index: 2; }
    .shutter-flash-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; border-radius: 50%; opacity: 0; pointer-events: none; z-index: 5; }
    .shutter-flash-overlay.flash { animation: lensFlash 0.15s ease-out; }
    @keyframes lensFlash { 0% { opacity: 0.8; } 100% { opacity: 0; } }
    .camera-interior { width: 100%; height: 100%; background: #0a0a0a; border-radius: 0 0 8px 8px; box-shadow: inset 0 0 40px #000; position: absolute; top: 0; left: 0; z-index: 1; display: flex; flex-direction: column; overflow: hidden; border-left: 1px solid #333; border-right: 1px solid #333; border-bottom: 1px solid #333; }

    #album-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #c00; font-family: 'Courier New', monospace; font-weight: bold; font-size: 16px; letter-spacing: 3px; z-index: 100; display: none; animation: blinkText 0.8s infinite; text-shadow: 0 0 5px rgba(204, 0, 0, 0.6); pointer-events: none; }
    @keyframes blinkText { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

   .album-container { flex: 1; padding: 20px; overflow-y: auto; display: none; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; align-content: flex-start; overscroll-behavior: contain; -webkit-overflow-scrolling: touch; }
    .album-container.active { display: grid; }
    .album-container::-webkit-scrollbar { width: 8px; }
    .album-container::-webkit-scrollbar-track { background: #111; }
    .album-container::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

    .album-photo { position: relative; border: 2px solid #333; cursor: pointer; transition: transform 0.2s, border-color 0.2s; aspect-ratio: 16 / 9; background: #000; width: 100%; }
    .album-photo img { width: 100%; height: 100%; object-fit: cover; }
    .album-photo.selected { border-color: #c00; transform: scale(0.95); }
    .album-photo.selected::after { content: '✔'; position: absolute; top: 2px; right: 2px; background: #c00; color: white; font-size: 12px; padding: 2px 4px; }
    .album-seq { position: absolute; top: 2px; left: 2px; font-family: 'Courier New'; font-size: 10px; color: #ff9900; background: rgba(0,0,0,0.7); padding: 1px 3px; }

    .film-strip-view { flex: 1; display: none; flex-direction: row; overflow-x: auto; overflow-y: hidden; white-space: nowrap; background: #050505; align-items: center; scroll-behavior: auto; perspective: none; padding-left: 85px; position: relative; z-index: 5; mask-image: linear-gradient(to right, transparent 0%, transparent 84px, black 86px); -webkit-mask-image: linear-gradient(to right, transparent 0%, transparent 84px, black 86px); }
    .film-strip-view.active { display: flex; }
    .film-strip-view::-webkit-scrollbar { height: 8px; display: none; }
    
    .static-canister-overlay { position: absolute; left: 15px; top: 42%; transform: translateY(-50%); width: 65px; height: 210px; z-index: 50 !important; pointer-events: none; filter: drop-shadow(5px 0 10px rgba(0,0,0,0.8)); }
    .canister-cylinder { width: 100%; height: 100%; background: linear-gradient(90deg, #222 0%, #555 30%, #222 60%, #111 100%); border-radius: 4px; box-shadow: 8px 0 20px rgba(0,0,0,1); border: 1px solid #333; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; }
    .canister-cylinder::before { content: ''; position: absolute; top: -12px; width: 100%; height: 12px; background: #333; border-radius: 50% 50% 0 0; border: 1px solid #444; background: radial-gradient(circle at 30% 30%, #666, #222); }
    .canister-cylinder::after { content: ''; position: absolute; bottom: -12px; width: 100%; height: 12px; background: #333; border-radius: 0 0 50% 50%; border: 1px solid #444; background: radial-gradient(circle at 30% 30%, #666, #222); }
    .canister-slot { position: absolute; right: -2px; top: 15%; height: 70%; width: 6px; background: #000; border-left: 1px solid #444; box-shadow: inset 2px 0 4px #000; }
    
    .film-frame-container { display: inline-flex; align-items: center; height: 180px; flex-shrink: 0; margin: 0; position: relative; background: transparent; border: none; padding: 0; transform-style: flat; width: auto; }
    .film-block { position: relative; height: 100%; width: 100%; display: block; background: #000; margin-right: -1px; }
    .film-block::before, .film-block::after { content: ''; position: absolute; left: 0; width: 100%; height: 14px; background-color: #000; background-image: linear-gradient(90deg, #111 60%, transparent 60%); background-size: 18px 100%; background-repeat: repeat-x; z-index: 5; }
    .film-block::before { top: 0; border-bottom: 1px solid #333; }
    .film-block::after { bottom: 0; border-top: 1px solid #333; }
    .film-frame-container.selected .film-block::before, .film-frame-container.selected .film-block::after { background-color: #8a5a00; background-image: linear-gradient(90deg, #cc8800 60%, transparent 60%); box-shadow: 0 0 8px rgba(255, 170, 0, 0.6); }
    .film-block-img { position: absolute; top: 14px; bottom: 14px; left: 0; right: 0; width: 100%; height: auto; background-repeat: no-repeat; background-size: cover; background-position: center; background-color: #000; z-index: 1; image-rendering: high-quality; }
    .film-meta-label { position: absolute; bottom: 18px; left: 8px; color: rgba(255, 255, 255, 0.85); font-family: 'Courier New', monospace; font-size: 12px; font-weight: bold; z-index: 20; text-shadow: 0 1px 2px rgba(0,0,0,0.9); pointer-events: none; }

    .album-controls { height: 50px; background: #181818; border-top: 1px solid #333; display: flex; justify-content: space-between; align-items: center; padding: 0 20px; gap: 10px; }
    .ac-left-group { display: flex; gap: 10px; }
    .ac-right-group { display: flex; gap: 10px; }
    .album-btn { background: transparent; border: 1px solid #666; color: #888; font-family: 'Courier New', monospace; padding: 5px 10px; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; }
    .album-btn.action { border-color: #c00; color: #c00; }
    .album-btn.action:hover { background: #c00; color: #fff; }
    .view-toggle-btn { width: 30px; height: 30px; border-radius: 4px; padding: 0; }
    .view-toggle-btn svg { fill: #888; width: 16px; height: 16px; }
    .view-toggle-btn.active { border-color: #fff; background: #333; }
    .view-toggle-btn.active svg { fill: #fff; }

    .copyright-mark { position: absolute; bottom: 14px; right: 22px; font-family: 'Arial', sans-serif; font-weight: bold; font-size: 12px; letter-spacing: 0.5px; color: rgba(255, 255, 255, 0.25); text-shadow: -1px -1px 1px rgba(0,0,0,0.9), 1px 1px 0 rgba(255,255,255,0.05); pointer-events: none; z-index: 5; text-transform: uppercase; }
    .film-door { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 120px; border: 4px solid #000; background: #1a1a1a; box-shadow: 0 1px 0 rgba(255,255,255,0.1), inset 0 0 10px #000; border-radius: 2px; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 2; transition: transform 0.1s; }
    .film-door:active { transform: translate(-50%, -50%) scale(0.98); }
    .memo-holder-frame { width: 170px; height: 90px; border: 2px solid #333; position: relative; background: #222; display: flex; justify-content: center; align-items: center; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.8); }
    .film-card { width: 150px; height: 70px; background: #f4e9c5; box-shadow: 1px 1px 4px rgba(0,0,0,0.5); display: flex; flex-direction: column; justify-content: center; align-items: center; transform: rotate(-1deg); transition: filter 0.5s ease; }
    .film-card::before, .film-card::after { content: ''; position: absolute; width: 100%; height: 6px; background: #333; transition: background 0.3s ease; }
    .film-card::before { top: 0; } .film-card::after { bottom: 0; }
    .film-card h3 { margin: 4px 0 0; font-size: 24px; font-weight: 900; color: #000; line-height: 1; font-family: Impact, sans-serif; }
    .film-card p { margin: 2px 0; font-size: 10px; color: #333; font-weight: bold; text-transform: uppercase; }

/* [用此版本完整替換舊的 #film-roll-overlay 到 .cl-iso 之間的所有 CSS] */
    #film-roll-overlay { 
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.85); 
        z-index: 6000; 
        display: none; 
        flex-direction: column; 
        justify-content: center; 
        align-items: center; 
        perspective: 1500px; /* 增強景深 */
        opacity: 0; 
        transition: opacity 0.3s; 
    }
    #film-roll-overlay.visible { opacity: 1; }

    .film-roll-container { 
        display: flex; 
        gap: 40px; 
        padding: 40px; 
        overflow-x: auto; 
        max-width: 90vw; 
        align-items: center; 
        scroll-behavior: smooth; 
        -webkit-overflow-scrolling: touch; 
    }
    .film-roll-container::-webkit-scrollbar { display: none; }

    /* --- 全新菲林筒樣式 --- */

    .film-canister {
        width: 85px; 
        height: 145px;
        position: relative;
        flex-shrink: 0;
        transform-style: preserve-3d;
        cursor: pointer;
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), filter 0.4s;
        transform: rotateX(-10deg) rotateY(10deg) scale(0.95);
        filter: drop-shadow(5px 15px 15px rgba(0,0,0,0.7));
    }
    .film-canister:hover, .film-canister.active {
        transform: rotateX(0deg) rotateY(0deg) scale(1.05) translateY(-5px);
        filter: drop-shadow(5px 25px 20px rgba(0,0,0,0.5));
    }

     .canister-body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    
    /* [核心修改] 將 border-radius 的值從 5px 增加到 8px，讓四角更圓潤 */
    border-radius: 17px 17px 8px 8px;
    
    display: flex;
    justify-content: center;
    align-items: center;
    border-left: 1px solid rgba(0,0,0,0.3);
    border-right: 1px solid rgba(0,0,0,0.3);
    box-shadow: 
        inset 0 14px 10px -10px rgba(0,0,0,0.7), 
        inset 0 -8px 6px -6px rgba(0,0,0,0.8);
}

    /* 筒身漸變顏色 (保持不變) */
    .canister-body--silver {
        background: linear-gradient(90deg, #6b6b6b 0%, #a7a7a7 10%, #e0e0e0 40%, #ffffff 50%, #e0e0e0 60%, #a7a7a7 90%, #6b6b6b 100%);
    }
    .canister-body--dark {
        background: linear-gradient(90deg, #151515 0%, #2e2e2e 10%, #4a4a4a 40%, #5c5c5c 50%, #4a4a4a 60%, #2e2e2e 90%, #151515 100%);
    }
    .canister-body--champagne {
        background: linear-gradient(90deg, #7e6c4a 0%, #b19d70 10%, #dfca9a 40%, #f9eecf 50%, #dfca9a 60%, #b19d70 90%, #7e6c4a 100%);
    }

    /* --- [核心魔法] 使用偽元素來雕刻頂部和底部 --- */

    /* 1. 雕刻頂部：包含平面、突出的轉軸、和中空的軸心 */
    .canister-body::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 14px;
        border-radius: 50% / 100% 100% 0 0;
        z-index: 5;
        
        /* [核心魔法] 將頂面圖層的 Y 軸位置推向極致，創造無可辯駁的高度差 */
        background-image:
            /* 第三層 (最頂)：中空的軸心頂面。位置極高 (at 50% 25%)，這是視覺高度的來源 */
            radial-gradient(ellipse 45% 35% at 50% 25%, 
                transparent 16%, #ccc 16.5%, #999 28%, transparent 28.5%
            ),

            /* 第二層 (中間)：轉軸的側壁。加深顏色，讓它成為一個堅實的基座 */
            radial-gradient(ellipse 50% 40% at 50% 50%,
                #181818 0%, #111111 40%, transparent 40.5%
            ),
            
            /* 第一層 (最底)：菲林筒頂部的凹陷大平面。位置大幅降低 (at 50% 60%)，為轉軸留出足夠的「生長」空間 */
            radial-gradient(ellipse 65% 50% at 50% 60%,
                #282828 0%, #1c1c1c 85%, transparent 85.5%);
        
        box-shadow: inset 0 1px 1px rgba(255,255,255,0.1);
    }

    /* 2. 雕刻底部：帶有立體感的黑色粗弧線 (筒身捲邊) */
   .canister-body::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 8px; /* 底部捲邊的高度 */
    border-radius: 50% / 0 0 100% 100%;
    z-index: 5;
    
    /* 基礎顏色 */
    background-color: #1a1a1a;

    /* [關鍵] 疊加一層柔和的放射狀漸變，模擬底部捲邊的圓潤高光 */
    background-image: 
        radial-gradient(ellipse 150% 80% at 50% 120%, 
            rgba(255,255,255,0.12) 0%, 
            transparent 50%
        );

    /* [關鍵] 使用內陰影來定義捲邊與筒身銜接處的輪廓 */
    box-shadow: 
        inset 0 1px 1px -1px rgba(255,255,255,0.2),
        inset 0 -2px 3px rgba(0,0,0,0.6);
}

    

    /* --- 菲林筒標籤 --- */
    .canister-label {
        width: 96%;
        height: 75%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 5px;
        border-radius: 3px;
        position: relative;
        z-index: 1;
        overflow: hidden; /* 非常重要，確保偽元素不會超出範圍 */
    }

    /* --- [核心魔法：曲面光影疊加層] --- */
    /* 這個偽元素會疊加在標籤背景之上，模擬圓柱光影 */
    .canister-label::before {
        content: '';
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: 2; /* 確保在背景之上，文字之下 */
        pointer-events: none; /* 讓滑鼠可以點擊到標籤本身 */

        /* [關鍵] 使用多層漸層來偽造光影和曲度 */
        background:
            /* 1. 頂部和底部的邊緣暗部，讓標籤看起來是嵌入的 */
            linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, transparent 10%, transparent 90%, rgba(0,0,0,0.3) 100%),
            
            /* 2. 左側和右側的圓柱暗部，這是製造圓柱感的核心 */
            linear-gradient(to right, rgba(0,0,0,0.5) 0%, transparent 25%, transparent 75%, rgba(0,0,0,0.5) 100%),
            
            /* 3. 左側的反光邊緣 (次高光) */
            linear-gradient(to right, transparent 5%, rgba(255,255,255,0.15) 15%, transparent 30%),
            
            /* 4. 中間偏右的主高光，模擬塑膠或金屬的反光質感 */
            linear-gradient(to right, transparent 40%, rgba(255,255,255,0.5) 48%, rgba(255,255,255,0.2) 52%, transparent 60%);
    }

    /* [之前版本的偽元素，現在用於紙質紋理] */
    .canister-label::after {
        content: '';
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        z-index: 3; /* 確保紋理在光影之上 */
    }
    /* 紙質紋理 (會覆蓋掉光澤效果) */
    .label-texture-paper::after {
        background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuNjUiIG51bU9jdGF2ZXM9IjMiIHN0aXRjaFRpbGVzPSJzdGl0Y2giLz48L2ZpbHRlcj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWx0ZXI9InVybCgjbnoaXNlKSIgb3BhY2l0eT0iMC4wOCIvPjwvc3ZnPg==');
        mix-blend-mode: overlay; /* 使用疊加模式，讓紋理更自然 */
    }

    .cl-name { 
        font-family: Impact, sans-serif; 
        font-size: 18px; 
        line-height: 1; 
        margin-bottom: 4px; 
        text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
    .cl-sub { 
        font-family: sans-serif; 
        font-size: 7px; 
        font-weight: bold; 
        text-transform: uppercase; 
        text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
    }
    .cl-iso { 
        font-family: 'Courier New', monospace; 
        font-weight: bold; 
        font-size: 11px; 
        margin-top: 5px; 
        border: 1px solid; /* 顏色由JS動態提供 */
        padding: 1px 4px; 
        border-radius: 2px;
        background: rgba(0,0,0,0.1);
    }

    #fs-viewfinder { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000; display: none; cursor: crosshair; touch-action: none; }
    #fs-canvas { width: 100%; height: 100%; object-fit: contain; }
    .fs-ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; box-shadow: inset 0 0 150px rgba(0,0,0,0.7); }
   .fs-guide-frame {
    position: absolute; 
    top: 50%; left: 50%; 
    transform: translate(-50%, -50%);
    
    /* [關鍵] 這是第一版的樣式 */
    border: 1px solid rgba(255,255,255,0.3) !important; 
    box-shadow: none !important; /* 移除復古陰影 */
    background: transparent !important;
    
    pointer-events: none;
    z-index: 5;
}

/* 2. 還原圓圈：單純的白色粗線圓圈，沒有背景色 */
.split-image-circle {
    position: absolute; 
    top: 50%; left: 50%; 
    transform: translate(-50%, -50%);
    
    /* [關鍵] 這是第一版的尺寸與樣式 */
    width: 60px !important; 
    height: 60px !important;
    border: 3px solid rgba(255,255,255,0.4) !important;
    border-radius: 50%;
    
    /* 移除復古版的背景與特效 */
    background: transparent !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
    
    transition: border-color 0.2s, box-shadow 0.2s;
    z-index: 6;
}

/* 3. 還原綠色對焦效果：經典的亮綠色光暈 */
.split-image-circle.focused {
    border-color: #0f0 !important;
    box-shadow: 0 0 20px #0f0, inset 0 0 10px #0f0 !important;
}


/* [新增] 焦距顯示器樣式 */
    .vf-zoom-indicator {
        position: absolute;
        top: 20px; /* 與頂部數據欄高度對齊 */
        left: 50%;
        transform: translateX(-50%); /* 絕對置中 */
        
        font-family: 'Courier New', monospace;
        font-weight: bold;
        font-size: 20px;
        letter-spacing: 1px;
        
        /* 改用琥珀金 (Amber/Gold) 以區分綠色數據 */
        color: #ffcc00; 
        text-shadow: 0 0 5px rgba(255, 204, 0, 0.8); /* 金色光暈 */
        
        /* 外框裝飾 */
        border: 2px solid #ffcc00;
        padding: 2px 10px;
        border-radius: 4px;
        background: rgba(60, 40, 0, 0.6); /* 深褐色半透明背景，增加對比度 */
        
        z-index: 20;
        transition: opacity 0.3s;
        pointer-events: none; /* 防止擋住手勢操作 */
    }

    /* 自拍模式下也維持琥珀色，與紅綠介面形成對比，非常好看 */
    body.is-selfie .vf-zoom-indicator {
        color: #ffcc00 !important;
        border-color: #ffcc00 !important;
    }

    
/* 4. 防止文字重疊 (保留上次的微調) */
.vf-data-top {
    top: 10px; /* 貼近頂部 */
    z-index: 20;
}
    .fs-data { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #0f0; font-family: 'Courier New', monospace; font-size: 20px; text-shadow: 0 0 5px #0f0; display: flex; gap: 30px; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 4px; }
    #vf-close-btn { position: absolute; top: 20px; left: 20px; pointer-events: auto; color: #fff; font-size: 40px; cursor: pointer; opacity: 0.6; font-family: Arial, sans-serif; line-height: 0.5; text-shadow: 0 0 4px #000; z-index: 10001; }
    #vf-close-btn:hover { opacity: 1; }

    .shutter-blind { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1500; animation: shutterAction 0.15s ease-in-out forwards; }
    .vf-shutter-blind { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 20; animation: shutterAction 0.15s ease-in-out forwards; pointer-events: none; }
    @keyframes shutterAction { 0% { opacity: 0; } 10% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }

    #review-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15,15,15,0.98); z-index: 2000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    #review-img { max-width: 90%; max-height: 70%; border: 10px solid #fff; box-shadow: 0 10px 50px rgba(0,0,0,1); }
    .review-controls { margin-top: 30px; display: flex; gap: 40px; }
    .btn-retro { background: transparent; border: 2px solid #fff; color: #fff; padding: 12px 30px; font-family: 'Courier New', monospace; font-weight: bold; font-size: 18px; cursor: pointer; }
    .btn-retro:active { background: #fff; color: #000; }

    #style-selector-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2500; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .style-options { display: flex; gap: 20px; margin-top: 20px; }
    .style-btn { width: 120px; height: 90px; background: #333; border: 2px solid #666; color: #fff; display: flex; justify-content: center; align-items: center; cursor: pointer; flex-direction: column; font-family: 'Courier New'; font-size: 12px; transition: 0.2s; }
    .style-btn:hover { border-color: #c00; color: #c00; }
    .style-preview { width: 60px; height: 40px; background: #111; margin-bottom: 8px; }
    .sp-std { border: none; }
    .sp-white { border: 2px solid white; border-bottom: 4px solid white; background: #333; } 
    .sp-film { border-top: 6px solid black; border-bottom: 6px solid black; background: #333; position: relative; }
    .sp-film::before, .sp-film::after { content: '...'; position: absolute; color: white; font-size: 8px; letter-spacing: 4px; left: 2px; }
    .sp-film::before { top: -8px; } .sp-film::after { bottom: -4px; }

    #developing-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 3000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    
    .photo-paper-container { transform: scale(0.9); display: flex; justify-content: center; align-items: center; margin-bottom: 30px; position: relative; overflow: hidden; transition: box-shadow 0.3s; }
    .photo-paper-container.wet-process { box-shadow: 0 0 50px rgba(0, 100, 255, 0.15), inset 0 0 20px rgba(0,0,0,0.5); }
    .photo-paper-container.wet-process::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.05), rgba(0,0,20,0.3)); pointer-events: none; z-index: 10; mix-blend-mode: overlay; }

    #dev-image-wrap { box-shadow: 0 0 50px #000; opacity: 0; max-height: 80vh; max-width: 80vw; transition: all 0.3s; }
    #dev-image-wrap.in-liquid { filter: url(#liquidFilter); }
    .dev-status-text { color: #888; font-family: monospace; font-size: 16px; letter-spacing: 2px; animation: pulse 1s infinite; margin-top: 20px;}
    
    #export-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 4000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .export-opt-group { margin-top: 20px; display: flex; gap: 20px; }

  #zoom-overlay { position: fixed !important; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); z-index: 2147483647; display: none; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
  #zoom-overlay.active { display: flex !important; }
  #zoom-img { max-width: 95vw; max-height: 90vh; width: auto; height: auto; box-shadow: 0 0 30px #000; object-fit: contain; margin: auto; display: block; }

    @keyframes pulse { 0%,100% {opacity:0.5} 50% {opacity:1}}
   @keyframes developProcess { 0% { opacity: 0; transform: scale(0.95); filter: brightness(0.1) sepia(1) blur(5px) url(#liquidFilter); } 40% { opacity: 0.6; filter: brightness(0.6) sepia(0.5) blur(2px) url(#liquidFilter); } 100% { opacity: 1; transform: scale(1); filter: brightness(1) sepia(0) blur(0) url(#liquidFilter); } }

.engraved-brand { position: absolute; top: 28px; left: 35px; width: 80px; text-align: center; font-family: 'Times New Roman', Times, serif; font-weight: 900; font-style: italic; font-size: 15px; letter-spacing: 0.5px; color: #151515; text-shadow: 0 1px 0 rgba(255, 255, 255, 0.7); pointer-events: none; display: none; z-index: 25; }
body.is-selfie .engraved-brand { display: block; animation: brandAppear 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
@keyframes brandAppear { from { opacity: 0; transform: translateY(-5px) scale(0.9); } to { opacity: 1; transform: translateY(0) scale(1); } }

.film-select-btn { position: absolute; top: 25px; left: 40px; width: 50px; height: 26px; background: linear-gradient(to bottom, #f0f0f0, #ccc); border: 1px solid #888; border-radius: 2px; font-family: sans-serif; font-size: 10px; font-weight: bold; color: #333; letter-spacing: 1px; display: none; justify-content: center; align-items: center; cursor: pointer; z-index: 40; box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.8); }
.film-select-btn:active { background: #bbb; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); transform: translateY(1px); color: #000; }
body.is-selfie .film-select-btn { display: flex; }

.selfie-shutter-btn { position: absolute; top: -12px; left: 55px; width: 46px; height: 18px; background: linear-gradient(to bottom, #e0e0e0, #999); border-radius: 4px 4px 0 0; border: 1px solid #888; border-bottom: none; cursor: pointer; z-index: 5; box-shadow: inset 0 1px 2px rgba(255,255,255,0.8), 0 -2px 5px rgba(0,0,0,0.2); transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1); display: none; }
.selfie-shutter-btn.pressed { transform: translateY(8px); transition: transform 0.05s ease-out; }
body.is-selfie .selfie-shutter-btn { display: block; }
body.is-selfie .shutter-release-btn { display: none; }

#retro-dialog-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 99999; display: none; justify-content: center; align-items: center; backdrop-filter: blur(2px); }
.retro-dialog-box { width: 320px; max-width: 85%; background: #111; border: 2px solid #666; box-shadow: 0 0 20px #000, inset 0 0 10px rgba(0,0,0,0.8); border-radius: 4px; display: flex; flex-direction: column; animation: dialogScaleIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
@keyframes dialogScaleIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
.rd-header { background: #222; color: #888; font-family: 'Arial', sans-serif; font-size: 10px; font-weight: bold; letter-spacing: 1px; padding: 8px 12px; border-bottom: 1px solid #333; text-transform: uppercase; }
.rd-body { padding: 25px 20px; color: #fff; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5; text-align: center; white-space: pre-wrap; font-weight: bold; text-shadow: 0 0 2px rgba(255,255,255,0.3); }
.rd-footer { display: flex; border-top: 1px solid #333; height: 50px; }
.rd-btn { flex: 1; background: transparent; border: none; color: #fff; font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
.rd-btn:active { background: #333; }
.rd-btn.cancel { border-right: 1px solid #333; color: #888; }
.rd-btn.confirm { color: #ff3333; text-shadow: 0 0 5px rgba(255, 50, 50, 0.4); }
.rd-btn.confirm:active { background: #300; }
.rd-btn.alert-ok { color: #fff; display: none; }

/* 1. 光學質感層：暗角 + 微微的磨砂感 */
.vf-optic-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
    
    /* 1. 調整漸層：透明區域從 50% 擴大到 65%，邊緣黑色不透明度從 0.95 降到 0.4 */
    background: radial-gradient(circle at center, transparent 65%, rgba(0,0,0,0.2) 90%, rgba(0,0,0,0.4) 100%),
                url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjZmZmIiBmaWxsLW9wYWNpdHk9IjAuMDUiLz4KPC9zdmc+'); 
    
    /* 2. 減弱內陰影 */
    box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
    z-index: 1;
}

/* [修改] 移除 UI 層的厚重暗角 */
.fs-ui-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    pointer-events: none; 
    
    /* [關鍵] 將原本的 box-shadow: inset 0 0 150px... 改為 none 或極淡 */
    box-shadow: none; 
}

/* 2. 指引框：移除原本的實線，改用角落標記 */
.fs-guide-frame {
    /* 位置由 JS 動態計算，這裡只設樣式 */
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    border: none; /* 移除舊邊框 */
    pointer-events: none;
    z-index: 2;
}

/* 角落標記 (Crop Marks) */
.corner {
    position: absolute; width: 20px; height: 20px;
    border-color: rgba(255, 255, 255, 0.7);
    border-style: solid;
    border-width: 0;
    box-shadow: 0 0 4px rgba(255,255,255,0.4);
}
.c-tl { top: 0; left: 0; border-top-width: 2px; border-left-width: 2px; }
.c-tr { top: 0; right: 0; border-top-width: 2px; border-right-width: 2px; }
.c-bl { bottom: 0; left: 0; border-bottom-width: 2px; border-left-width: 2px; }
.c-br { bottom: 0; right: 0; border-bottom-width: 2px; border-right-width: 2px; }

/* 中央十字 */
.center-cross {
    position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
    transform: translate(-50%, -50%);
}
.center-cross::before { content:''; position:absolute; top:9px; left:0; width:100%; height:2px; background:rgba(255,255,255,0.4); }
.center-cross::after { content:''; position:absolute; left:9px; top:0; height:100%; width:2px; background:rgba(255,255,255,0.4); }

/* 3. 裂像對焦圈優化 */
.split-image-circle {
    /* 保持 JS 控制顯示/隱藏 */
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.2);
    background: rgba(255,255,255,0.05);
    backdrop-filter: contrast(1.2); /* 讓圈內稍微亮一點 */
    z-index: 3;
}
/* 裂像中間的水平線 */
.split-line {
    position: absolute; top: 50%; left: 0; width: 100%; height: 1px;
    background: rgba(255,255,255,0.4);
}

/* 4. 復古數據介面 (OSD) */
.fs-ui-layer {
    font-family: 'Courier New', monospace;
    font-weight: bold;
    color: #50ff50; /* 經典電子綠 */
    text-shadow: 0 0 5px rgba(80, 255, 80, 0.8);
    z-index: 10;
}

/* 頂部 */
.vf-data-top {
    position: absolute; top: 20px; left: 60px; right: 20px;
    display: flex; justify-content: space-between; align-items: center;
}
.vf-mode-badge {
    border: 2px solid #50ff50;
    padding: 2px 8px;
    border-radius: 2px;
    font-size: 16px;
    background: rgba(0, 50, 0, 0.5);
}
.vf-batt { display: flex; align-items: center; gap: 5px; font-size: 12px; }
.batt-icon { width: 24px; height: 10px; border: 2px solid #50ff50; padding: 1px; position: relative; }
.batt-icon::after { content:''; position:absolute; right:-4px; top:2px; width:2px; height:4px; background:#50ff50; }
.batt-level { width: 70%; height: 100%; background: #50ff50; animation: battBlink 5s infinite; }
@keyframes battBlink { 0%,90% {opacity:1;} 95% {opacity:0.2;} 100% {opacity:1;} }

/* 底部 */
.vf-data-bottom {
    position: absolute; bottom: 20px; width: 100%;
    display: flex; justify-content: space-between; align-items: flex-end;
    padding: 0 40px;
}

/* 曝光表 */
.exp-meter { display: flex; align-items: center; gap: 5px; font-size: 14px; margin-bottom: 5px; }
.exp-scale { display: flex; gap: 6px; position: relative; align-items: center; margin: 0 5px; }
.exp-dot { width: 4px; height: 4px; background: #50ff50; opacity: 0.5; border-radius: 50%; }
.exp-dot.center { width: 6px; height: 6px; opacity: 1; background: #ff5050; box-shadow: 0 0 5px #ff0000; } /* 中央紅點 */
.exp-needle {
    position: absolute; 
    bottom: -8px; 
    /* 預設在中間 */
    left: 50%; 
    
    width: 0; 
    height: 0; 
    border-left: 4px solid transparent; 
    border-right: 4px solid transparent; 
    border-bottom: 6px solid #50ff50; /* 螢光綠 */
    
    transform: translateX(-50%); /* 確保指針尖端對準位置 */
    
    pointer-events: none; /* 確保不擋住點擊 */
    
    /* [關鍵] 移除 animation，加入 transition 讓移動變順暢 */
    transition: left 0.2s ease-out; 
}

/* [新增] 自拍模式下的指針顏色 (紅色) */
body.is-selfie .exp-needle {
    border-left-color: transparent !important;
    border-right-color: transparent !important;
    border-bottom-color: #ff5050 !important; /* 只保留底部紅色 */
    background-color: transparent !important;
}

/* 2. 修正圓點：恢復成實心圓 */
/* 原本的設定把背景變透明了，這裡改回紅色填充 */
body.is-selfie .exp-dot {
    background-color: #ff5050 !important;
    border: none !important; /* 移除邊框，變回實心 */
    opacity: 0.5;
}

/* 3. 中央點：保持高亮 */
body.is-selfie .exp-dot.center {
    background-color: #ff0000 !important;
    opacity: 1;
    box-shadow: 0 0 6px #ff0000 !important;
}
@keyframes meterShake { 0% {left:50%} 20% {left:45%} 40% {left:55%} 60% {left:48%} 100% {left:50%} }

/* 參數文字 */
.vf-params { display: flex; gap: 20px; font-size: 18px; letter-spacing: 1px; }
.vf-yellow { color: #ffff50; text-shadow: 0 0 5px rgba(255, 255, 80, 0.8); } /* 黃色數值 */

/* 計數器 */
.vf-counter-box { text-align: right; }
.vf-label { font-size: 10px; display: block; opacity: 0.8; }
.vf-big-num { font-size: 28px; line-height: 1; color: #ff5050; text-shadow: 0 0 8px #ff0000; }

/* 關閉按鈕稍微調整位置以避開 UI */
#vf-close-btn { top: 15px; left: 20px; font-size: 32px; text-shadow: none; opacity: 0.5; }

/* 自拍模式下的顏色變化 (變成紅色錄影風) */
body.is-selfie .fs-ui-layer, 
body.is-selfie .vf-mode-badge, 
body.is-selfie .batt-icon {
    color: #50ff50 !important;
    border-color: #50ff50 !important;
}

/* 2. 修正普通刻度點：變回實心綠色 */
body.is-selfie .exp-dot {
    background-color: #50ff50 !important; /* 綠色背景 */
    border: none !important;              /* 移除邊框 */
    opacity: 0.5;
}

/* 3. 修正指針：變回綠色三角形 */
body.is-selfie .exp-needle {
    border-left-color: transparent !important;  /* 左右透明 */
    border-right-color: transparent !important; /* 左右透明 */
    border-bottom-color: #50ff50 !important;    /* 底部綠色 */
    background-color: transparent !important;   /* 背景透明 */
}

/* 4. 修正電池：變回綠色 */
body.is-selfie .batt-level {
    background-color: #50ff50 !important;
}

/* 5. [關鍵] 只有「中央點」維持紅色高亮 */
body.is-selfie .exp-dot.center {
    background-color: #ff5050 !important; /* 紅色背景 */
    box-shadow: 0 0 5px #ff0000 !important; /* 紅色光暈 */
    opacity: 1;
}

    /* [修復] 強制讓曝光按鈕可以被點擊 */
#exp-btn-minus, 
#exp-btn-plus {
    pointer-events: auto !important; /* 關鍵：恢復點擊感應 */
    cursor: pointer;
    z-index: 100; /* 確保浮在最上層 */
    padding: 10px; /* 增加點擊範圍，手指好按 */
    user-select: none; /* 防止雙擊選取文字 */
}

/* 確保指針不會擋住點擊 */
.exp-needle {
    pointer-events: none;
}

    /* [新增] 日期開關樣式 */
.date-checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #888;
    background: transparent;
    position: relative;
    transition: all 0.2s;
}

/* 勾選狀態 (實心紅) */
.date-checkbox.checked {
    background: #c00;
    border-color: #fff;
    box-shadow: 0 0 5px #c00;
}

/* 勾選時的小勾勾 */
.date-checkbox.checked::after {
    content: '✔';
    position: absolute;
    top: -4px;
    left: 2px;
    color: white;
    font-size: 14px;
    font-weight: bold;
}

#date-option-wrapper:hover .date-checkbox { border-color: #fff; }
#date-option-wrapper:hover span { color: #fff; }
    
</style>
</head>
<body>

    <svg style="position: absolute; width:0; height:0; pointer-events:none;">
      <defs>
        <filter id="liquidFilter">
          <feTurbulence type="turbulence" baseFrequency="0.01 0.05" numOctaves="2" result="turbulence" seed="0" />
          <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="15" xChannelSelector="R" yChannelSelector="G" result="distorted" />
          <feSpecularLighting in="turbulence" specularConstant="0.75" specularExponent="20" lighting-color="#ffffff" surfaceScale="2" result="specular">
             <fePointLight x="500" y="-100" z="200" />
          </feSpecularLighting>
          <feComposite in="specular" in2="distorted" operator="in" result="specular-composite" />
          <feComposite in="distorted" in2="specular-composite" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" />
        </filter>
      </defs>
    </svg>

    <div id="fullscreen-prompt"><p>FULLSCREEN REQUIRED</p><button id="enter-fs-btn">POWER ON</button></div>
    <div id="orientation-lock"><svg viewBox="0 0 24 24"><path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/></svg><p>ROTATE DEVICE</p></div>

    <div id="fs-viewfinder">
        <!-- 1. 畫布 (不變) -->
        <canvas id="fs-canvas"></canvas>
        
        <!-- 2. 復古光學質感層 (保留，增加質感) -->
        <div class="vf-optic-layer"></div>
        
        <!-- 3. UI 層 -->
        <div class="fs-ui-layer">
            <div id="vf-close-btn" title="Exit">×</div>
            
            <!-- 導引框 -->
            <div class="fs-guide-frame" id="fsGuideFrame"></div>
    
            <!-- 對焦圈 -->
            <div class="split-image-circle" id="splitCircle"></div>
    
            <!-- 頂部數據 -->
            <div class="vf-data-top">
                <div class="vf-mode-badge" id="fs-mode-text">B&W</div>
                <div class="vf-batt"><span>BAT</span><div class="batt-icon"><div class="batt-level"></div></div></div>
            </div>

            <!-- [新增] 這裡加入焦距顯示器 -->
            <div id="fs-zoom-text" class="vf-zoom-indicator">1.0x</div>
    
            <!-- 底部數據 -->
            <div class="vf-data-bottom">
              <div class="exp-meter">
                <span id="exp-btn-minus" style="font-size:20px;">-</span>
                <div class="exp-scale">
                    <div class="exp-dot"></div><div class="exp-dot"></div><div class="exp-dot center"></div><div class="exp-dot"></div><div class="exp-dot"></div>
                    <div class="exp-needle" id="exp-needle"></div>
                </div>
                <span id="exp-btn-plus" style="font-size:20px;">+</span>
              </div>
                <div class="vf-params"><span class="vf-yellow">1/125</span><span class="vf-yellow">F2.8</span><span class="vf-iso">ISO 400</span></div>
                <div class="vf-counter-box"><span class="vf-label">REM</span><span id="fs-counter" class="vf-big-num">36</span></div>
            </div>
        </div>
    </div>

    <div id="film-roll-overlay">
        <h2 style="color:white; font-family:'Courier New'; margin-bottom:30px; text-shadow:0 0 5px #fff;">SELECT FILM STOCK</h2>
        <div class="film-roll-container" id="filmRollContainer"></div>
        <p style="color:#666; font-size:12px; margin-top:20px; font-family:sans-serif;">TAP TO LOAD</p>
    </div>

    <div id="camera-container">
        <div class="top-plate">
            <div class="viewfinder-wrap" id="vfTrigger" title="Live View"><canvas class="vf-glass" id="smallCanvas"></canvas></div>
            <div class="film-select-btn" id="filmSelectBtn">FILM</div>
            <div class="function-group">
                <div class="engraved-brand">LUMIGRAPH</div>
                <div class="top-row-btns"><div class="flat-lock-btn" id="orientationBtn" title="Lock Orientation"><span>LOCK</span></div><div class="selfie-btn" id="selfie-toggle" title="Selfie Mode"></div></div>
                <div class="compact-switch-container" id="sketchModeSwitch" title="Real/Art Mode"><span id="lbl-real" class="cs-label active">REAL</span><div class="cs-track"><div class="cs-knob"></div></div><span id="lbl-sketch" class="cs-label">ART</span></div>
            </div>
            <div class="selfie-shutter-btn" id="selfieShutterBtn"></div>
            <div id="back-controls-group">
                <div class="lever-base" id="leverBase"></div>
                <div class="advance-lever" id="advanceLever"><div class="lever-grip"></div></div>
                <div class="shutter-release-btn" id="shutterBtn"></div>
                <div class="right-controls">
                    <div class="counter-window"><span class="counter-digits" id="frameCounter">S</span></div>
                    <div class="mode-switch-container" id="rollModeSwitch"><div class="mode-labels"><span>1</span><span>36</span></div><div class="switch-track"><div class="switch-knob"></div></div></div>
                </div>
            </div>
            <div id="front-controls-group" class="front-controls-group" style="display:none;">
                <div class="cable-release-container">
                    <div class="cable-plunger-wrapper" id="cablePlunger"><div class="cable-button-head"></div><div class="cable-stem"></div><div class="cable-disc"></div><div class="cable-grip-body"></div></div>
                </div>
                <div class="front-viewfinder-frame" id="frontVfTrigger"><canvas class="front-vf-glass" id="frontCanvas"></canvas></div>
                <div class="front-shutter-btn" id="frontShutterBtn"></div>
            </div>
            <div class="serial-number">NO. 854021</div>
            <div class="prism-hump"></div>
            <div class="ready-light" id="readyLight"></div>
        </div>

        <div class="camera-body">
            <div class="camera-interior">
                <div id="album-loader">READING DATA...</div>
                <div class="album-container" id="albumGrid"></div>
                <div class="static-canister-overlay" id="staticCanister"><div class="canister-cylinder"><div class="canister-slot"></div></div></div>
                <div class="film-strip-view active" id="filmStripView"></div>
                <div class="album-controls">
                    <div class="ac-left-group">
                         <button class="view-toggle-btn active" id="view-film" title="Film View"><svg viewBox="0 0 24 24"><path d="M20 4h-2V2h-2v2H8V2H6v2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM8 18H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V8h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V8h2v2z"/></svg></button>
                         <button class="view-toggle-btn" id="view-grid" title="Grid View"><svg viewBox="0 0 24 24"><path d="M4 4h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4zM4 10h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4zM4 16h4v4H4zm6 0h4v4h-4zm6 0h4v4h-4z"/></svg></button>
                    </div>
                    <div class="ac-right-group">
                        <button class="album-btn" id="alb-sel-all">ALL</button>
                        <button class="album-btn action" id="alb-delete" style="border-color:#c00; color:#c00;">DEL</button>
                        <button class="album-btn action" id="alb-download">SAVE</button>
                        <button class="album-btn action" id="alb-share">SHARE</button>
                    </div>
                </div>
            </div>
            <div class="camera-front-face" id="frontFace">
                <div class="realistic-lens"><div class="lens-barrel"><div class="lens-glass-element"><div class="lens-reflection"></div><div class="shutter-flash-overlay" id="shutterFlash"></div></div></div></div>
            </div>
            <div class="back-door-wrapper" id="backDoorWrapper">
                <div class="back-door-face">
                    <div class="copyright-mark">©Designed by Chan Kwun Kin</div>
                    <div class="film-door" id="filmDoor" title="Change Film Type"><div class="memo-holder-frame"><div class="film-card"><h3 id="modeTitle">B&W</h3><p id="modeSub">TRI-X 400</p></div></div></div>
                </div>
                <div class="back-door-interior"><div class="pressure-plate"></div></div>
            </div>
            <div class="back-lock" id="backLock" title="Open Back"></div>
        </div>
    </div>

   <div id="style-selector-overlay">
        <!-- 標題 -->
        <h2 style="color:white; font-family:'Courier New'; text-align:center;">SELECT PRINT STYLE</h2>
        
        <!-- 三個外框選項 -->
        <div class="style-options">
            <div class="style-btn" data-style="standard">
                <div class="style-preview sp-std"></div>STANDARD
            </div>
            <div class="style-btn" data-style="white">
                <div class="style-preview sp-white"></div>INSTANT
            </div>
            <div class="style-btn" data-style="film">
                <div class="style-preview sp-film"></div>FILM
            </div>
        </div>

        <!-- [修正位置] 將日期開關放在這個 DIV 結束標籤的「裡面」 -->
        <div id="date-option-wrapper" style="margin-top: 30px; display: flex; align-items: center; gap: 12px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s;">
            <div id="date-checkbox" class="date-checkbox checked"></div>
            <span style="color: #ddd; font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold; letter-spacing: 1px; text-shadow: 0 0 5px rgba(0,0,0,0.5);">IMPRINT DATE</span>
        </div>
    </div> 


              
    <div id="review-overlay"><img id="review-img" src="" alt="Review"><div class="review-controls"><button class="btn-retro" id="btn-discard">DISCARD</button><button class="btn-retro" id="btn-keep">KEEP</button></div></div>
    <div id="developing-overlay"><div class="photo-paper-container"><img id="dev-image-wrap" src="" alt="Developing"></div><div class="dev-status-text" id="devStatus">DEVELOPING...</div></div>
    <div id="zoom-overlay"><img id="zoom-img" src="" alt="Zoomed Photo"></div>
    <div id="export-modal">
        <h2 style="color:#c00; font-family:'Courier New'">EXPORT OPTIONS</h2>
        <input type="text" id="exp-text-input" placeholder="Enter caption..." maxlength="20" style="margin-top:15px; padding:10px; width:220px; font-family:'Noto Serif TC', serif; font-weight:600; font-size: 18px; background:#222; border:1px solid #666; color:#fff; text-align:center; outline:none;">
        <p style="color:#fff; font-family:sans-serif; margin-top:15px;">Include Serial Number?</p>
        <div class="export-opt-group"><button class="btn-retro" id="exp-no-serial">NO SERIAL</button><button class="btn-retro" id="exp-with-serial" style="border-color:#c00; color:#c00">WITH SERIAL</button></div>
        <button class="btn-retro" id="exp-cancel" style="margin-top:30px; border:none; opacity:0.5">CANCEL</button>
    </div>

    <video id="video-source" autoplay playsinline style="display:none"></video>
    <!-- [MODIFIED] This canvas is now WebGL enabled -->
    <canvas id="process-canvas" style="display:none"></canvas> 
    <canvas id="final-canvas" style="display:none"></canvas>

    <div id="retro-dialog-overlay">
        <div class="retro-dialog-box">
            <div class="rd-header">SYSTEM MESSAGE</div>
            <div class="rd-body" id="rd-message"></div>
            <div class="rd-footer">
                <button class="rd-btn cancel" id="rd-btn-cancel">CANCEL</button>
                <button class="rd-btn confirm" id="rd-btn-confirm">CONFIRM</button>
                <button class="rd-btn alert-ok" id="rd-btn-ok">OK</button>
            </div>
        </div>
    </div>

<script>

let currentRollState = Math.random(); // 這是控制底片風格的靜態亂數
    
    /* --- 1. WEBGL RENDERER CLASS (NEW) --- */
        class WebGLRenderer {
        constructor(canvas) {
            this.canvas = canvas;
            // 使用 alpha: false 提升效能
            this.gl = canvas.getContext('webgl', { preserveDrawingBuffer: true, alpha: false });
            if (!this.gl) { console.error("WebGL not supported"); return; }
            this.program = null;
            this.texture = null;
            this.init();
        }

        init() {
            const gl = this.gl;
            
            // Vertex Shader：包含 Zoom 邏輯
            const vsSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                uniform float u_flipY;
                uniform float u_flipX;
                uniform float u_zoom; 

                void main() {
                    gl_Position = vec4(a_position, 0, 1);
                    
                    // 數碼變焦運算
                    vec2 center = vec2(0.5, 0.5);
                    vec2 tex = a_texCoord;
                    tex = (tex - center) / u_zoom + center;

                    if(u_flipX > 0.5) tex.x = 1.0 - tex.x;
                    if(u_flipY > 0.5) tex.y = 1.0 - tex.y;
                    v_texCoord = tex;
                }
            `;

            // Fragment Shader：包含所有濾鏡模式 (含 HK 1990)
           const fsSource = `
                precision highp float;
                
                uniform sampler2D u_image;
                varying vec2 v_texCoord;
                uniform int u_mode; 
                uniform float u_seed;
                uniform float u_stat_seed;
                uniform vec2 u_texSize; 

                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }

                vec3 adjustColor(vec3 color, float brightness, float contrast, float saturation) {
                    vec3 avg = vec3(0.5);
                    color = mix(avg, color, contrast);
                    color = color + (brightness - 1.0);
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    color = mix(vec3(gray), color, saturation);
                    return color;
                }

                void main() {
                    vec2 uv = v_texCoord;
                    vec4 color = texture2D(u_image, uv);
                    vec3 c = color.rgb;

                     // --- [核心新增] ---
                    // 新增一個索引為 11 的「直通模式」，不進行任何處理，直接輸出原始畫面。
                    if (u_mode == 11) { // NEUTRAL PASSTHROUGH
                        gl_FragColor = color;
                        return; // 直接結束，跳過後續所有濾鏡效果
                    }
                    // --- [新增結束] ---

                    // [修改] 素描模式現在是 20 以上
                    if (u_mode >= 20) {
                        float w = 1.0 / u_texSize.x; 
                        float h = 1.0 / u_texSize.y;
                        
                        vec3 cR = texture2D(u_image, uv + vec2(w, 0.0)).rgb;
                        vec3 cB = texture2D(u_image, uv + vec2(0.0, h)).rgb;
                        
                        float gray = dot(c, vec3(0.333));
                        float grayR = dot(cR, vec3(0.333));
                        float grayB = dot(cB, vec3(0.333));
                        
                        float diff = abs(gray - grayR) + abs(gray - grayB);
                        
                        if (diff < 0.01) diff = 0.0;

                        // 注意：這裡的 index 也要對應上面 JS 的修改 (20, 21, ...)
                        if (u_mode == 20) { // Pencil
                            if(diff > 0.06) gl_FragColor = vec4(vec3(0.15), 1.0);
                            else gl_FragColor = vec4(vec3(0.92 + rand(uv)*0.08), 1.0);
                        } else if (u_mode == 22) { // Ink
                            if(diff > 0.08 || gray < 0.3) gl_FragColor = vec4(vec3(0.05), 1.0);
                            else gl_FragColor = vec4(1.0);
                        } else if (u_mode == 24) { // Cyber
                             if(diff > 0.1) gl_FragColor = vec4(0.0, 1.0, 0.2, 1.0);
                             else {
                                float grid = (mod(gl_FragCoord.y, 4.0) < 1.0) ? 0.1 : 0.0;
                                gl_FragColor = vec4(0.0, grid, 0.0, 1.0);
                             }
                        } else if (u_mode == 26) { // HK Neon
                             if(diff > 0.08) {
                                 if(c.r > c.g && c.r > c.b) gl_FragColor = vec4(1.0, 0.0, 0.3, 1.0);
                                 else if(c.b > 0.5) gl_FragColor = vec4(0.0, 0.6, 1.0, 1.0);
                                 else gl_FragColor = vec4(1.0);
                             } else gl_FragColor = vec4(0.05, 0.02, 0.06, 1.0);
                        } else if (u_mode == 21) { // Crayon
                            float noise = (rand(uv) - 0.5) * 0.2;
                            c = c + noise;
                            if(diff > 0.06) gl_FragColor = vec4(c * 0.6, 1.0);
                            else gl_FragColor = vec4(c + 0.2, 1.0);
                        } else if (u_mode == 25) { // Blueprint
                            if(diff > 0.06) gl_FragColor = vec4(0.9, 0.95, 1.0, 1.0);
                            else gl_FragColor = vec4(0.0, 0.2, 0.5 + rand(uv)*0.1, 1.0);
                        } else if (u_mode == 23) { // Oil
                             c = floor(c * 6.0) / 6.0; 
                             if(diff > 0.05) c *= 0.8; 
                             gl_FragColor = vec4(c, 1.0);
                        } else if (u_mode == 27) { // Shuimo
                             float ink = gray;
                             if (diff > 0.05) ink -= 0.3; 
                             ink = clamp(ink, 0.0, 1.0);
                             ink = smoothstep(0.2, 0.9, ink); 
                             gl_FragColor = vec4(vec3(ink), 1.0);
                        } else {
                            // Default Edge
                            float edge = step(0.06, diff);
                            gl_FragColor = vec4(mix(vec3(1.0), vec3(0.0), edge), 1.0);
                        }
                        return;
                    }

                    // Real Modes
                    if (u_mode == 0) { // [BW] STREET 400 - 經典人文黑白
                        // 模擬黃色濾鏡：稍微壓暗藍色天空，提亮膚色
                        float gray = dot(c, vec3(0.4, 0.5, 0.1)); 
                        // S型曲線增加中間調對比
                        c = vec3(smoothstep(0.05, 0.95, gray));
                        // 輕微提升暗部，模擬 Tri-X 沖洗特性
                        c = mix(vec3(0.02), vec3(1.0), c); 
                        float noise = (rand(uv*u_seed) - 0.5) * 0.12; // 顆粒稍粗
                        c += noise;
                    } 
                    else if (u_mode == 1) { // [COLOR] GAME-CAM - 復古低像素
                        // 先稍微增加飽和度，讓色彩量化後更鮮豔
                        c = adjustColor(c, 1.0, 1.1, 1.2);
                        c = floor(c * 8.0) / 8.0; 
                    } 
                    else if (u_mode == 2) { // [DIGI] CCD SENSOR - 早期數碼相機
                        // 模擬 CCD 的高光溢出 (Highlight Bloom) 和偏洋紅膚色
                        c = adjustColor(c, 1.05, 1.1, 1.1);
                        c.g *= 0.98; // 稍微減綠，讓膚色透紅
                        c.b = floor(c.b * 16.0) / 16.0; // 藍色通道位元深度較低
                    }
                    else if (u_mode == 3) { // [HCBW] FINE 100 - 森山大道風格高反差
                        // 模擬紅色濾鏡：大幅壓暗藍色，天空變黑
                        float gray = dot(c, vec3(0.6, 0.35, 0.05));
                        // 強烈 S 曲線
                        gray = smoothstep(0.15, 0.85, gray);
                        // 死黑，但保留極高光細節
                        c = vec3(pow(gray, 1.2));
                        float noise = (rand(uv*u_seed) - 0.5) * 0.15; // 粗顆粒
                        c += noise;
                    } 
                    else if (u_mode == 4) { // [FILM: TEAL] KYOTO 400 - 日系電影感
                        // 暗部注入青色，亮部注入暖橘 (Split Toning)
                        // 1. 基礎調整
                        c = adjustColor(c, 1.0, 0.95, 0.9);
                        
                        // 2. 膚色保護 (Skin Protection)：偵測紅色區域，減少被青色污染
                        float skinMask = smoothstep(0.1, 0.6, c.r - c.b);
                        
                        // 3. 暗部推向青藍 (Teal Shadow)
                        c.b = max(c.b, 0.15 * (1.0 - c.r)); 
                        c.g = mix(c.g, c.b * 0.9, 0.3 * (1.0 - skinMask)); // 避開皮膚
                        
                        // 4. 亮部微暖
                        c.r += c.r * 0.1 * c.g; 
                    } 
                    else if (u_mode == 5) { // [FILM: SUN] CALI 200 - 西海岸暖陽
                        // 金色調：亮部偏奶油黃，暗部偏暖褐
                        c = adjustColor(c, 1.05, 1.0, 1.2);
                        
                        // 亮部注入黃色 (Add Yellow to Highlights)
                        float lum = dot(c, vec3(0.333));
                        c.r += lum * 0.15;
                        c.g += lum * 0.10;
                        
                        // 暗部微暖紅
                        vec3 warmShadow = vec3(0.05, 0.02, 0.0);
                        c = max(c, warmShadow);
                        
                        // 稍微降低藍色，製造復古暖感
                        c.b *= 0.85; 
                    } 
                    else if (u_mode == 6) { // [FILM: VIVID] SLIDE 100 - 正片負沖/Ektar
                        // 高飽和、高對比、黑色下沉
                        c = adjustColor(c, 1.0, 1.3, 1.45);
                        
                        // 模擬正片的紅綠色偏移 (Reds/Greens pop)
                        c.r = pow(c.r, 0.95); // 紅色更厚實
                        c.b *= 0.95; // 藍色稍暗，像偏振鏡效果
                        
                        // 加深暗部 (Crush Blacks)
                        c = pow(c, vec3(1.1));
                     }  else if (u_mode == 7) { // [FILM: AGED] RANDOM EXPIRED (穩定版)
                        
                        // 使用 u_stat_seed (靜態種子) 來決定這張照片的命運
                        // 這樣取景時不會閃爍，但每張照片的效果都不同
                        
                        // 1. 決定隨機參數
                        float rndType = rand(vec2(u_stat_seed, 10.0));      // 決定偏色類型
                        float rndPush = rand(vec2(u_stat_seed, 20.0));      // 決定谷沖強度 (對比度)
                        float rndGrainSize = rand(vec2(u_stat_seed, 30.0)); // 決定顆粒粗細

                        // 2. 隨機谷沖 (Random Push Processing)
                        // rndPush 越大，對比越高，飽和度越低 (模擬迫沖)
                        // Contrast 範圍: 1.0 (正常) ~ 1.35 (高反差)
                        float dynamicContrast = 1.0 + (rndPush * 0.35); 
                        float dynamicSat = 1.2 - (rndPush * 0.3);       
                        c = adjustColor(c, 1.05, dynamicContrast, dynamicSat);

                        // 3. 穩定的隨機偏色 (三種過期命運)
                        if (rndType < 0.33) { 
                            // [Type A] 嚴重偏藍/青 (Blue Shift)
                            c.r *= 0.85; 
                            c.g *= 0.95;
                            c.b *= 1.15; 
                            vec3 blueFog = vec3(0.02, 0.05, 0.12);
                            c = max(c, blueFog);
                            c = pow(c, vec3(0.95)); // 稍微過曝感
                        } 
                        else if (rndType < 0.66) { 
                            // [Type B] 灰綠褪色 (Faded Green)
                            c = mix(vec3(dot(c, vec3(0.333))), c, 0.7); // 額外降低飽和
                            c.g += 0.05;
                            c.r += 0.02;
                            c = mix(vec3(0.08, 0.1, 0.08), vec3(1.0), c); // 霧化暗部
                        } 
                        else { 
                            // [Type C] 暖褐洋紅 (Magenta/Brown Shift)
                            c.b *= 0.75; 
                            c.r *= 1.1; 
                            vec3 brownShadow = vec3(0.08, 0.04, 0.02);
                            c = max(c, brownShadow);
                            // 高光偏黃
                            c.r += (1.0-c.r) * 0.08;
                            c.g += (1.0-c.g) * 0.04;
                        }

                        // 4. 隨機暗角 (隨機強度與大小)
                        float vignetteStr = 0.3 + (rndPush * 0.5); // 谷沖越強，暗角越重
                        float dist = distance(uv, vec2(0.5));
                        float vignette = smoothstep(1.3, 0.3, dist * (0.8 + rndType * 0.4));
                        c *= mix(1.0, vignette, vignetteStr);

                        // 5. 隨機銀鹽顆粒 (Random Grain)
                        // 這是你要求的：不一定全部粗糙
                        // grainStrength 範圍從 0.04 (極細) 到 0.16 (極粗)
                        float grainStrength = 0.04 + (rndGrainSize * 0.12);
                        
                        // 使用 u_seed (動態種子) 讓噪點位置跳動，避免看起來像靜態貼圖
                        float noise = (rand(uv * u_seed * 2.0) - 0.5) * grainStrength;
                        c += noise;
                    }

                    else if (u_mode == 8) { // [FILM: SOFT] AIRY 400H - 空氣感/人像
                        // 提亮暗部 + 柔光
                        c = adjustColor(c, 1.15, 0.85, 0.9);
                        
                        // 注入微量粉嫩色調 (Pinkish tint) 讓膚色好看
                        c.r += 0.03;
                        c.b += 0.02;
                        
                        // 霧面暗部 (Matte Shadow)
                        c = mix(vec3(0.05, 0.04, 0.05), vec3(1.0), c);
                    } 
                    else if (u_mode == 9) { // [FILM: MOOD] HK 1990 - 王家衛電影風格
                        // 強化綠色暗部 + 洋紅亮部 (Cinematic Green/Magenta split)
                        
                        // 1. 對比度增強
                        c = adjustColor(c, 1.0, 1.2, 1.1);
                        
                        // 2. 暗部強烈偏綠
                        float lum = dot(c, vec3(0.333));
                        float shadowFactor = 1.0 - smoothstep(0.0, 0.7, lum);
                        c.g += shadowFactor * 0.15;
                        c.b = mix(c.b, c.g * 0.5, shadowFactor); // 暗部藍色減少
                        
                        // 3. 亮部補償洋紅 (保持膚色不發綠)
                        float highlightFactor = smoothstep(0.6, 1.0, lum);
                        c.r += highlightFactor * 0.1;
                        c.b += highlightFactor * 0.08;
                        
                        // 4. 經典暗角
                        float offX = (rand(vec2(u_seed, 11.0)) - 0.5) * 0.015; 
                        float offY = (rand(vec2(u_seed, 22.0)) - 0.5) * 0.015;
                        float dist = distance(uv, vec2(0.5 + offX, 0.5 + offY));
                        float vignette = smoothstep(1.1, 0.35, dist); 
                        c *= vignette;
                    } 
                    else if (u_mode == 10) { // [FILM: AOI] V3 - 你的特調 (維持不變)
                        c = adjustColor(c, 1.0, 1.25, 1.15);
                        float blueDom = smoothstep(0.2, 0.7, c.b - c.r);
                        c.g = mix(c.g, min(1.0, c.b * 1.05), blueDom * 0.5);
                        float redDom = smoothstep(0.1, 0.5, c.r - c.b);
                        c.g += redDom * 0.04;
                        vec3 liftColor = vec3(0.01, 0.04, 0.09); 
                        c = mix(liftColor, vec3(1.0), c);
                        c = pow(c, vec3(1.1));
                        float lum = dot(c, vec3(0.299, 0.587, 0.114));
                        float shadowMask = 1.0 - smoothstep(0.0, 0.4, lum);
                        c.b += shadowMask * 0.03; 
                        c.g += shadowMask * 0.01; 
                        c *= vec3(0.96, 1.0, 1.02);
                    }

                    if(u_mode != 1 && u_mode != 2) {
                        // 銀鹽顆粒：這裡使用原本的噪點邏輯，強度 0.08 剛好是中等顆粒感
                        float noise = (rand(uv * u_seed) - 0.5) * 0.08;
                        c += noise;
                    }
                    
                    gl_FragColor = vec4(c, 1.0);
                }
            `;

            // [修復關鍵] 這些函數之前丟失了，導致畫面變黑
            const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
            this.program = this.createProgram(gl, vertexShader, fragmentShader);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,1, 1,1, 0,0, 1,0]), gl.STATIC_DRAW); 

            this.a_position = gl.getAttribLocation(this.program, 'a_position');
            this.a_texCoord = gl.getAttribLocation(this.program, 'a_texCoord');
            this.u_flipY = gl.getUniformLocation(this.program, 'u_flipY');
            this.u_flipX = gl.getUniformLocation(this.program, 'u_flipX');
            this.u_mode = gl.getUniformLocation(this.program, 'u_mode');
            this.u_seed = gl.getUniformLocation(this.program, 'u_seed');
            this.u_stat_seed = gl.getUniformLocation(this.program, 'u_stat_seed');
            this.u_texSize = gl.getUniformLocation(this.program, 'u_texSize');
            this.u_zoom = gl.getUniformLocation(this.program, 'u_zoom');

            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }

        // [修復關鍵] 補回缺失的 compileShader 函數
        compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader Error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // [修復關鍵] 補回缺失的 createProgram 函數
        createProgram(gl, vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program Link Error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        render(videoElement, modeIndex, isSelfie, zoomLevel, statSeed) {
            const gl = this.gl;
            gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            gl.useProgram(this.program);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoElement);

            gl.enableVertexAttribArray(this.a_position);
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(this.a_texCoord);
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,1, 1,1, 0,0, 1,0]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(this.a_texCoord, 2, gl.FLOAT, false, 0, 0);

            gl.uniform1f(this.u_flipY, 0.0);
            gl.uniform1f(this.u_flipX, isSelfie ? 1.0 : 0.0);
            gl.uniform1i(this.u_mode, modeIndex);
            gl.uniform1f(this.u_seed, Math.random());
            gl.uniform2f(this.u_texSize, this.canvas.width, this.canvas.height);
            gl.uniform1f(this.u_zoom, zoomLevel);
            gl.uniform1f(this.u_stat_seed, statSeed);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
    }
    

    /* --- DATABASE & INIT --- */
    const DB_NAME = "RetroCamDB_ProMax"; const TEMP_STORE = "temp_roll"; const ALBUM_STORE = "user_album"; let db;
    function initDB() { return new Promise((resolve, reject) => { const request = indexedDB.open(DB_NAME, 3); request.onupgradeneeded = (e) => { db = e.target.result; if (!db.objectStoreNames.contains(TEMP_STORE)) db.createObjectStore(TEMP_STORE, { autoIncrement: true }); if (!db.objectStoreNames.contains(ALBUM_STORE)) db.createObjectStore(ALBUM_STORE, { keyPath: "id", autoIncrement: true }); }; request.onsuccess = (e) => { db = e.target.result; resolve(db); }; request.onerror = () => reject("DB Error"); }); }
    function saveToTemp(dataUrl) { return new Promise((resolve) => { const tx = db.transaction([TEMP_STORE], "readwrite"); tx.objectStore(TEMP_STORE).add({ image: dataUrl, date: new Date() }).onsuccess = () => resolve(true); }); }
    function getTempCount() { return new Promise((resolve) => { const tx = db.transaction([TEMP_STORE], "readonly"); tx.objectStore(TEMP_STORE).count().onsuccess = (e) => resolve(e.target.result); }); }
    function getTempPhotos() { return new Promise((resolve) => { const tx = db.transaction([TEMP_STORE], "readonly"); tx.objectStore(TEMP_STORE).getAll().onsuccess = (e) => resolve(e.target.result); }); }
    function clearTemp() { return new Promise(resolve => { db.transaction([TEMP_STORE], "readwrite").objectStore(TEMP_STORE).clear().onsuccess = resolve; }); }
    function saveToAlbum(processedImage, serialNumber, styleInfo, w, h) { 
        return new Promise(resolve => { 
            const tx = db.transaction([ALBUM_STORE], "readwrite"); 
            tx.objectStore(ALBUM_STORE).add({ image: processedImage, timestamp: Date.now(), serial: serialNumber, style: styleInfo, width: w || 0, height: h || 0 }).onsuccess = resolve; 
        }); 
    }
    function getAlbumPhotos() { return new Promise(resolve => { const tx = db.transaction([ALBUM_STORE], "readonly"); tx.objectStore(ALBUM_STORE).getAll().onsuccess = (e) => resolve(e.target.result); }); }
    function deleteFromAlbum(ids) { return new Promise(resolve => { const tx = db.transaction([ALBUM_STORE], "readwrite"); const store = tx.objectStore(ALBUM_STORE); ids.forEach(id => store.delete(id)); tx.oncomplete = resolve; }); }

    /* --- VARS --- */


/* --- [新增] 數碼變焦 (Digital Zoom) 變數與邏輯 (含 UI 顯示) --- */
    let currentZoom = 1.0;
    const minZoom = 1.0;
    const maxZoom = 3.0; // 最大放大 3 倍
    let initialPinchDistance = 0;
    let startZoomLevel = 1.0;
    
    // 防止兩指鬆開時誤觸雙擊重置
    let isPinching = false; 

    const fsViewfinderEl = document.getElementById('fs-viewfinder');
    const zoomTextEl = document.getElementById('fs-zoom-text'); // [新增] 獲取 UI 元素

    // [新增] 輔助函數：更新 UI 文字
    function updateZoomDisplay() {
        if(zoomTextEl) {
            zoomTextEl.textContent = currentZoom.toFixed(1) + "x";
        }
    }

    // 1. 雙指接觸開始
    fsViewfinderEl.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            isPinching = true;
            initialPinchDistance = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
            startZoomLevel = currentZoom;
        }
    }, { passive: false }); 

    // 2. 雙指移動 (變焦中)
    fsViewfinderEl.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            isPinching = true;

            const currentDistance = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );

            if (initialPinchDistance > 0) {
                const pinchRatio = currentDistance / initialPinchDistance;
                let newZoom = startZoomLevel * pinchRatio;
                
                // 限制範圍
                newZoom = Math.max(minZoom, Math.min(newZoom, maxZoom));
                currentZoom = newZoom;
                
                // [新增] 即時更新 UI
                updateZoomDisplay();
            }
        }
    }, { passive: false });

    // 3. 雙擊重置
    let lastTapTime = 0;
    fsViewfinderEl.addEventListener('touchend', (e) => {
        // 如果剛剛是縮放手勢，不要執行雙擊判定
        if (isPinching) {
            if (e.touches.length === 0) {
                isPinching = false;
            }
            return;
        }

        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;
        
        if (tapLength < 300 && tapLength > 0) {
            currentZoom = 1.0;
            initialPinchDistance = 0;
            // [新增] 重置時更新 UI
            updateZoomDisplay();
        }
        lastTapTime = currentTime;
    });

    
    let isRollMode = localStorage.getItem('rollMode') === 'true'; let currentFrame = 0; let pendingPhoto = null; let globalSerialCounter = parseInt(localStorage.getItem('global_serial_counter') || '1'); let isSelfieMode = false; let isSketchMode = false; let isOrientationLocked = localStorage.getItem('orientationLocked') === 'true'; let isFilmViewMode = true; let isMenuLocked = false;
    
    // Multi-exposure State
    let isFilmAdvanced = true; 
    let exposureCanvas = document.createElement('canvas'); 
    let currentReviewCanvas = null;
    let exposureCtx = exposureCanvas.getContext('2d');
    
    const REAL_MODES = [
        { id: 'BW', name: 'B&W', sub: 'STREET 400', color: '#000', idx:0, 
          canisterColor: 'silver', 
          labelBg: 'linear-gradient(135deg, #f0f0f0, #ccc)', 
          labelColor: '#111' },
        
        { id: 'COLOR', name: 'COLOR', sub: 'GAME-CAM', color: '#c00', idx:1,
          canisterColor: 'dark', 
          labelBg: 'linear-gradient(to top, #7d0000, #c00)', 
          labelColor: '#fff' },
          
        { id: 'CCD', name: 'DIGI', sub: 'CCD SENSOR', color: '#0055cc', idx:2,
          canisterColor: 'silver', 
          labelBg: 'linear-gradient(#0055cc, #002288)', 
          labelColor: '#fff' },
          
        { id: 'HCBW', name: 'HC-BW', sub: 'FINE 100', color: '#555', idx:3,
          canisterColor: 'dark', 
          labelBg: '#111', 
          labelColor: '#fff' },
          
        { id: 'FILM_TEAL', name: 'FILM: TEAL', sub: 'KYOTO 400', color: '#008080', idx:4,
          canisterColor: 'champagne', 
          labelBg: 'linear-gradient(to right, #005f5f, #008080, #a0d8d8)', 
          labelColor: '#fff',
          texture: 'paper' },
          
        { id: 'FILM_SUN', name: 'FILM: SUN', sub: 'CALI 200', color: '#ffcc00', idx:5,
          canisterColor: 'silver', 
          labelBg: 'linear-gradient(135deg, #ff8c00, #ffcc00)', 
          labelColor: '#4d2600' },
          
        { id: 'FILM_VIVID', name: 'FILM: VIVID', sub: 'SLIDE 100', color: '#ff0055', idx:6,
          canisterColor: 'silver', 
          labelBg: 'linear-gradient(45deg, #ff0055, #ff66a3, #fff)', 
          labelColor: '#000' },
          
        { id: 'FILM_AGED', name: 'FILM: AGED', sub: 'EURO 800', color: '#8b4513', idx:7,
          canisterColor: 'dark', 
          labelBg: 'linear-gradient(180deg, #5c3d20, #8b4513)', 
          labelColor: '#f0e68c',
          texture: 'paper' },
          
        { id: 'FILM_SOFT', name: 'FILM: SOFT', sub: 'AIRY 400H', color: '#90e0ef', idx:8,
          canisterColor: 'champagne', 
          labelBg: 'linear-gradient(to bottom, #d1f5f5, #90e0ef)', 
          labelColor: '#006666' },
          
        { id: 'FILM_MOOD', name: 'FILM: MOOD', sub: 'HK 1990', color: '#006633', idx:9,
          canisterColor: 'dark', 
          labelBg: 'linear-gradient(#004d26, #008040)', 
          labelColor: '#ffdd99' },
          
        { id: 'FILM_AOI', name: 'FILM: AOI', sub: 'TOKYO BLUE', color: '#0080ff', idx:10,
          canisterColor: 'silver', 
          labelBg: 'linear-gradient(to top, #0050a0, #0080ff, #a0d8ff)', 
          labelColor: '#fff' }
    ];
    const SKETCH_MODES = [ 
        { id: 'SKETCH_BW', name: 'PENCIL', sub: '2B GRAPHITE', color: '#333', idx:20 }, 
        { id: 'SKETCH_COL', name: 'CRAYON', sub: 'SOFT PASTEL', color: '#d2691e', idx:21 }, 
        { id: 'SKETCH_INK', name: 'INK', sub: 'COMIC PEN', color: '#000', idx:22 }, 
        { id: 'SKETCH_OIL', name: 'OIL', sub: 'IMPASTO', color: '#8b4513', idx:23 }, 
        { id: 'SKETCH_CYBER', name: 'CYBER', sub: 'NEON GRID', color: '#0f0', idx:24 }, 
        { id: 'SKETCH_BLUE', name: 'BLUE', sub: 'BLUEPRINT', color: '#4169e1', idx:25 }, 
        { id: 'SKETCH_HK_NEON', name: 'HK NEON', sub: 'NIGHT LIGHTS', color: '#ff00cc', idx:26 }, 
        { id: 'SKETCH_SHUIMO', name: 'SHUIMO', sub: 'INK WASH', color: '#111', idx:27 } 
    ];
    let savedMode = localStorage.getItem('camModeIdx'); let currentModeIdx = savedMode ? parseInt(savedMode) : 0;
    function getModes() { return isSketchMode ? SKETCH_MODES : REAL_MODES; }
    function validateModeIndex() { const modes = getModes(); if (currentModeIdx < 0 || currentModeIdx >= modes.length) currentModeIdx = 0; }
    validateModeIndex();

    /* --- AUDIO --- */
    const shutterAudio = new Audio('https://taira-komori.net/sound_os2/electric01/camera1.mp3'); shutterAudio.preload = 'auto';
    const latchAudio = new Audio('https://taira-komori.net/sound_os2/electric01/fluorescent_switch1.mp3'); latchAudio.volume = 1.0; latchAudio.preload = 'auto';
    const AudioContext = window.AudioContext || window.webkitAudioContext; const actx = new AudioContext();
    function playShutterSound() { shutterAudio.currentTime = 0; const playPromise = shutterAudio.play(); if (playPromise !== undefined) { playPromise.catch(error => { if (actx.state === 'suspended') actx.resume(); const t = actx.currentTime; const oscClick = actx.createOscillator(); const gainClick = actx.createGain(); oscClick.type = 'square'; oscClick.frequency.setValueAtTime(800, t); oscClick.frequency.exponentialRampToValueAtTime(100, t + 0.05); gainClick.gain.setValueAtTime(0.5, t); gainClick.gain.exponentialRampToValueAtTime(0.01, t + 0.05); oscClick.connect(gainClick).connect(actx.destination); oscClick.start(t); oscClick.stop(t + 0.05); }); } }
    function playLeverSound() { if (actx.state === 'suspended') actx.resume(); const t = actx.currentTime; for(let i=0; i<5; i++) { const osc = actx.createOscillator(); const gain = actx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, t + i*0.06); osc.frequency.exponentialRampToValueAtTime(100, t + i*0.06 + 0.03); gain.gain.setValueAtTime(1.2, t + i*0.06); gain.gain.exponentialRampToValueAtTime(0.01, t + i*0.06 + 0.03); osc.connect(gain); gain.connect(actx.destination); osc.start(t + i*0.06); osc.stop(t + i*0.06 + 0.04); } }

    /* --- DOM ELEMENTS --- */
    const video = document.getElementById('video-source');
    const smallCanvas = document.getElementById('smallCanvas'); const smallCtx = smallCanvas.getContext('2d', { alpha: false });
    const frontCanvas = document.getElementById('frontCanvas'); const frontCtx = frontCanvas.getContext('2d', { alpha: false });
    const fsCanvas = document.getElementById('fs-canvas'); const fsCtx = fsCanvas.getContext('2d', { alpha: false });
    
    // WebGL Canvas
    const processCanvas = document.getElementById('process-canvas');
    let webGLRenderer = null;

    const finalCanvas = document.getElementById('final-canvas'); const finalCtx = finalCanvas.getContext('2d');
    
    const rollModeSwitch = document.getElementById('rollModeSwitch'); const sketchModeSwitch = document.getElementById('sketchModeSwitch'); const orientationBtn = document.getElementById('orientationBtn');
    const frameCounterUI = document.getElementById('frameCounter'); const fsCounter = document.getElementById('fs-counter'); const readyLight = document.getElementById('readyLight'); const leverBase = document.getElementById('leverBase'); const advanceLever = document.getElementById('advanceLever'); const shutterBtn = document.getElementById('shutterBtn'); const frontShutterBtn = document.getElementById('frontShutterBtn'); const cablePlunger = document.getElementById('cablePlunger');
    const vfTrigger = document.getElementById('vfTrigger'); const frontVfTrigger = document.getElementById('frontVfTrigger'); const fsViewfinder = document.getElementById('fs-viewfinder'); const vfCloseBtn = document.getElementById('vf-close-btn'); const fsGuideFrame = document.getElementById('fsGuideFrame'); const splitCircle = document.getElementById('splitCircle');
    const backLock = document.getElementById('backLock'); const backDoorWrapper = document.getElementById('backDoorWrapper'); const frontFace = document.getElementById('frontFace'); const shutterFlash = document.getElementById('shutterFlash'); const selfieToggle = document.getElementById('selfie-toggle'); const backControls = document.getElementById('back-controls-group'); const frontControls = document.getElementById('front-controls-group');
    const albumGrid = document.getElementById('albumGrid'); const filmStripView = document.getElementById('filmStripView'); const btnViewFilm = document.getElementById('view-film'); const btnViewGrid = document.getElementById('view-grid');
    const styleOverlay = document.getElementById('style-selector-overlay'); const devOverlay = document.getElementById('developing-overlay'); const devImageWrap = document.getElementById('dev-image-wrap'); const devStatus = document.getElementById('devStatus'); const filmCard = document.querySelector('.film-card'); const modeTitle = document.getElementById('modeTitle'); const modeSub = document.getElementById('modeSub'); const fsPrompt = document.getElementById('fullscreen-prompt'); const zoomOverlay = document.getElementById('zoom-overlay'); const zoomImg = document.getElementById('zoom-img');
    const filmRollOverlay = document.getElementById('film-roll-overlay'); const filmRollContainer = document.getElementById('filmRollContainer'); const filmDoor = document.getElementById('filmDoor');
    const staticCanister = document.getElementById('staticCanister');

    /* --- DIALOG SYSTEM --- */
    const rdOverlay = document.getElementById('retro-dialog-overlay');
    const rdMessage = document.getElementById('rd-message');
    const rdBtnCancel = document.getElementById('rd-btn-cancel');
    const rdBtnConfirm = document.getElementById('rd-btn-confirm');
    const rdBtnOk = document.getElementById('rd-btn-ok');

    function showRetroDialogUI(msg, type = 'confirm') {
        return new Promise((resolve) => {
            rdMessage.textContent = msg;
            rdOverlay.style.display = 'flex';
            rdBtnCancel.style.display = 'none'; rdBtnConfirm.style.display = 'none'; rdBtnOk.style.display = 'none';
            if (type === 'confirm') {
                rdBtnCancel.style.display = 'block'; rdBtnConfirm.style.display = 'block';
                rdBtnConfirm.onclick = () => { rdOverlay.style.display = 'none'; resolve(true); };
                rdBtnCancel.onclick = () => { rdOverlay.style.display = 'none'; resolve(false); };
            } else {
                rdBtnOk.style.display = 'block';
                rdBtnOk.onclick = () => { rdOverlay.style.display = 'none'; resolve(true); };
            }
        });
    }
    async function retroConfirm(text) { return await showRetroDialogUI(text, 'confirm'); }
    async function retroAlert(text) { return await showRetroDialogUI(text, 'alert'); }

    function updateModeUI() { const modes = getModes(); if(currentModeIdx >= modes.length) currentModeIdx = 0; const m = modes[currentModeIdx]; modeTitle.textContent = m.name; modeSub.textContent = m.sub; document.getElementById('fs-mode-text').textContent = m.name; const h3 = filmCard.querySelector('h3'); h3.style.color = m.color; const styleEl = document.createElement('style'); styleEl.innerHTML = `.film-card::before, .film-card::after { background: ${m.color} !important; }`; const oldStyle = document.getElementById('film-card-style'); if(oldStyle) oldStyle.remove(); styleEl.id = 'film-card-style'; document.head.appendChild(styleEl); }
    updateModeUI();

    async function initSystem() { 
        await initDB(); 
        // Init WebGL
        webGLRenderer = new WebGLRenderer(processCanvas);
        
        if (isRollMode) { rollModeSwitch.classList.add('mode-36'); currentFrame = await getTempCount(); } else { rollModeSwitch.classList.remove('mode-36'); currentFrame = 0; } 
        updateCounterDisplay(); updateLeverUI(); 
        if(isOrientationLocked) { orientationBtn.classList.add('locked'); try { if (screen.orientation && screen.orientation.lock) {} } catch(e){} } 
    }
    function updateCounterDisplay() { if (!isRollMode) { frameCounterUI.textContent = "S"; fsCounter.textContent = "1"; } else { if (currentFrame === 0) frameCounterUI.textContent = "S"; else if (currentFrame >= 36) frameCounterUI.textContent = "E"; else frameCounterUI.textContent = currentFrame; fsCounter.textContent = (36 - currentFrame) + " LEFT"; } }
    function updateLeverUI() { const isEndOfRoll = isRollMode && currentFrame >= 36; if (!isFilmAdvanced || isEndOfRoll) { readyLight.classList.add('active'); leverBase.classList.add('glow'); } else { readyLight.classList.remove('active'); leverBase.classList.remove('glow'); } }

    document.getElementById('enter-fs-btn').addEventListener('click', () => { startFullscreenAndCamera(); });
    function startFullscreenAndCamera() { const el = document.documentElement; const rfs = el.requestFullscreen || el.webkitRequestFullScreen; if (rfs) { rfs.call(el).then(() => { initSystem().then(initCamera); if(isOrientationLocked && screen.orientation && screen.orientation.lock) { screen.orientation.lock('landscape').catch(()=>{}); } }).catch(() => { initSystem().then(initCamera); }); } }
   async function initCamera() { 
        try { 
            if(video.srcObject) { video.srcObject.getTracks().forEach(track => track.stop()); } 
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: isSelfieMode ? 'user' : 'environment', 
                    width: { ideal: 1280 }, 
                    height: { ideal: 720 },
                    // [新增] 請求曝光模式為連續自動 (這是讓 EV 生效的前提)
                    advanced: [{ exposureMode: 'continuous' }]
                }, 
                audio: false 
            }); 
            
            video.srcObject = stream; 
            video.onloadedmetadata = () => { 
                video.play(); 
                renderLoop(); 
                
                // [新增] 相機啟動後，初始化曝光控制按鈕
                initExposureControl();
            }; 
        } catch (err) { 
            console.error("Camera Error", err); 
        } 
    }
    function enforceFullscreen() { if (!document.fullscreenElement) { fsPrompt.style.display = 'flex'; document.getElementById('camera-container').style.display = 'none'; fsViewfinder.style.display = 'none'; } }
    document.addEventListener('fullscreenchange', enforceFullscreen);
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden') { if (video.srcObject) { video.srcObject.getTracks().forEach(track => track.stop()); video.srcObject = null; } if(shutterAudio) { shutterAudio.pause(); shutterAudio.currentTime = 0; } } else if (document.visibilityState === 'visible') { enforceFullscreen(); setTimeout(() => { if (!video.srcObject || !video.srcObject.active) { initCamera(); } }, 300); } });
    orientationBtn.addEventListener('click', async () => { isOrientationLocked = !isOrientationLocked; orientationBtn.classList.toggle('locked', isOrientationLocked); localStorage.setItem('orientationLocked', isOrientationLocked); if (isOrientationLocked) { try { if (screen.orientation && screen.orientation.lock) { await screen.orientation.lock('landscape'); } } catch (e) { } } else { try { if (screen.orientation && screen.orientation.unlock) { screen.orientation.unlock(); } } catch (e) {} } });

    document.getElementById('filmSelectBtn').addEventListener('click', () => { isMenuLocked = false; openFilmSelector(); });
    document.getElementById('selfieShutterBtn').addEventListener('click', handleShutter);

     function renderFilmSelector() {
        const modes = getModes();
        filmRollContainer.innerHTML = ''; // 清空容器

        modes.forEach((m, index) => {
            const canister = document.createElement('div');
            canister.className = 'film-canister';
            if (index === currentModeIdx) {
                canister.classList.add('active');
            }

            const bodyClass = `canister-body canister-body--${m.canisterColor || 'silver'}`;
            const labelTextureClass = m.texture === 'paper' ? 'label-texture-paper' : '';

            // [核心修改] HTML 結構簡化，移除了 canister-cap 元素
            // 所有視覺效果都將由 .canister-body 和它的偽元素來完成
            canister.innerHTML = `
                <div class="${bodyClass}">
                    <div class="canister-label ${labelTextureClass}" style="background: ${m.labelBg};">
                        <div class="cl-name" style="color: ${m.labelColor};">${m.name}</div>
                        <div class="cl-sub" style="color: ${m.labelColor}; opacity: 0.8;">${m.sub}</div>
                        <div class="cl-iso" style="border-color: ${m.labelColor}; color: ${m.labelColor};">400</div>
                    </div>
                </div>
            `;

            canister.addEventListener('click', (e) => {
                e.stopPropagation();
                selectModeFromRoll(index);
            });
            filmRollContainer.appendChild(canister);
        });
    }
    function openFilmSelector() { if (backDoorWrapper.classList.contains('open')) return; renderFilmSelector(); filmRollOverlay.style.display = 'flex'; void filmRollOverlay.offsetWidth; filmRollOverlay.classList.add('visible'); }
    function selectModeFromRoll(index) { currentModeIdx = index; localStorage.setItem('camModeIdx', currentModeIdx); isMenuLocked = false; filmRollOverlay.classList.remove('visible'); setTimeout(() => { filmRollOverlay.style.display = 'none'; filmCard.style.filter = 'blur(10px)'; processCanvas.style.filter = 'blur(10px)'; updateModeUI(); setTimeout(() => { filmCard.style.filter = 'none'; processCanvas.style.filter = 'none'; }, 400); }, 300); }
    filmDoor.addEventListener('click', () => { isMenuLocked = false; openFilmSelector(); });
    filmRollOverlay.addEventListener('click', (e) => { if(e.target === filmRollOverlay) { if (isMenuLocked) { const container = document.getElementById('filmRollContainer'); container.style.transition = 'transform 0.1s'; container.style.transform = 'scale(1.05)'; setTimeout(() => { container.style.transform = 'scale(1)'; setTimeout(() => container.style.transition = '', 100); }, 100); return; } filmRollOverlay.classList.remove('visible'); setTimeout(() => filmRollOverlay.style.display = 'none', 300); } });
        
    selfieToggle.addEventListener('click', () => {
        isSelfieMode = !isSelfieMode;
        if (isSelfieMode) { document.body.classList.add('is-selfie'); backDoorWrapper.style.display = 'none'; frontFace.style.display = 'flex'; backControls.style.display = 'none'; frontControls.style.display = 'block'; } else { document.body.classList.remove('is-selfie'); backDoorWrapper.style.display = 'block'; frontFace.style.display = 'none'; backControls.style.display = 'block'; frontControls.style.display = 'none'; }
        initCamera(); 
    });

    sketchModeSwitch.addEventListener('click', () => {
        isSketchMode = !isSketchMode;
        sketchModeSwitch.classList.toggle('mode-sketch', isSketchMode);
        document.getElementById('lbl-real').classList.toggle('active', !isSketchMode);
        document.getElementById('lbl-sketch').classList.toggle('active', isSketchMode);
        currentModeIdx = 0;
        isMenuLocked = true;
        openFilmSelector();
    });

   function renderLoop() {
    requestAnimationFrame(renderLoop);
    if (!video.srcObject || !video.srcObject.active || video.paused || !webGLRenderer) return;

    const modes = getModes(); 
    validateModeIndex(); 
    const mode = modes[currentModeIdx];
    
    // Resize Canvas if needed - 這部分沿用您提供的正確版本
    let w = 640; let h = 360; 
    if (!isSketchMode && (mode.id === 'COLOR' || mode.id === 'BW')) { w = 320; h = 180; } 
    if (processCanvas.width !== w) { processCanvas.width = w; processCanvas.height = h; }

    // --- [核心修改：整合中性預覽邏輯] ---
    // 預設情況下，預覽索引就是當前模式的索引
    let previewModeIdx = mode.idx;

    // 但如果當前模式是 AGED (索引 7)，我們就在預覽時強制使用中性的「直通模式」(索引 11)
    if (mode.idx === 7) {
        previewModeIdx = 11; 
    }
    // --- [修改結束] ---

    // 在呼叫 WebGL 渲染時，傳入的是我們剛剛決定的 previewModeIdx，而不是固定的 mode.idx
    webGLRenderer.render(video, previewModeIdx, isSelfieMode, currentZoom, currentRollState);
    
    // Copy to Viewfinders (2D) - 這部分沿用您提供的正確版本
    const isPixelated = (!isSketchMode && (mode.id === 'COLOR' || mode.id === 'BW'));
    
    if (!isSelfieMode) { 
        if (smallCanvas.width !== w) { smallCanvas.width = w; smallCanvas.height = h; } 
        smallCanvas.style.imageRendering = isPixelated ? 'pixelated' : 'auto'; 
        smallCtx.drawImage(processCanvas, 0, 0, w, h); 
    } else { 
        if (frontCanvas.width !== w) { frontCanvas.width = w; frontCanvas.height = h; } 
        frontCanvas.style.imageRendering = isPixelated ? 'pixelated' : 'auto'; 
        frontCtx.drawImage(processCanvas, 0, 0, w, h); 
    }

    if (fsViewfinder.style.display === 'block') { 
        if (fsCanvas.width !== w) { fsCanvas.width = w; fsCanvas.height = h; } 
        fsCanvas.style.imageRendering = isPixelated ? 'pixelated' : 'auto'; 
        fsCtx.drawImage(processCanvas, 0, 0, w, h);
    }
}


    // [新代碼] 綁定兩個觀景窗按鈕，統一使用相同的開啟邏輯
vfTrigger.addEventListener('click', openFullScreenViewfinder);
frontVfTrigger.addEventListener('click', openFullScreenViewfinder);
 
    
    vfCloseBtn.addEventListener('click', (e) => { e.stopPropagation(); fsViewfinder.style.display = 'none'; });
    fsViewfinder.addEventListener('click', (e) => { if(e.target.id !== 'vf-close-btn') handleShutter(e); });
    shutterBtn.addEventListener('click', handleShutter);
    frontShutterBtn.addEventListener('click', handleShutter);
    cablePlunger.addEventListener('click', (e) => { e.stopPropagation(); cablePlunger.classList.add('pressed'); setTimeout(() => cablePlunger.classList.remove('pressed'), 200); handleShutter(e); });


// [新增] 模擬自動對焦：先白圈，0.8秒後變綠圈
// [新增] 模擬自動對焦：先白圈，0.8秒後變綠圈
function simulateAutoFocus() {
    const circle = document.getElementById('splitCircle');
    const viewfinder = document.getElementById('fs-viewfinder');
    
    if(!circle || !viewfinder) return;
    
    // 1. 重置狀態：移除 focused 類別 (變回白色粗框)
    circle.classList.remove('focused');
    
    // 2. 設定延遲：模擬鏡頭對焦的時間 (800毫秒)
    setTimeout(() => {
        // 只有當觀景窗還「開著」的時候才變綠
        // 防止使用者快速開關導致觀景窗關閉後還觸發變綠
        if(viewfinder.style.display === 'block') {
            circle.classList.add('focused');
            
            // (選用) 如果你想加入「逼逼」的對焦音效，可以在這裡呼叫
            // if(actx.state !== 'suspended') playFocusBeep(); 
        }
    }, 800);
}

    
// [新增] 模擬按下快門時，光圈快門數值跳動
function randomizeOSD() {
    const shutters = ['1/60', '1/125', '1/250', '1/500', '1/1000'];
    const apertures = ['F1.4', 'F2.0', 'F2.8', 'F4.0', 'F5.6', 'F8.0'];
    
    const s = shutters[Math.floor(Math.random() * shutters.length)];
    const a = apertures[Math.floor(Math.random() * apertures.length)];
    
    const params = document.querySelectorAll('.vf-yellow');
    if(params.length >= 2) {
        params[0].textContent = s;
        params[1].textContent = a;
    }
}

 // [新增] 共用函數：打開全螢幕觀景窗 (統一邏輯)
    function openFullScreenViewfinder(e) {
        if (e) e.stopPropagation();
        
        // 確保相機已啟動
        if (!video.srcObject || !video.srcObject.active) return;

        fsViewfinder.style.display = 'block';
        
        // 1. 每次進入，曝光歸零
        resetExposure();

        // 2. 每次進入，變焦歸零
        currentZoom = 1.0;
        
        // [新增] 重置焦距顯示為 1.0x
        const zoomTextEl = document.getElementById('fs-zoom-text');
        if(zoomTextEl) zoomTextEl.textContent = "1.0x";

        // 3. 計算白框大小
        updateFSGuideFrame();
        
        // 4. 更新復古數值
        randomizeOSD();

        // 5. 確保剛打開時圓圈是白色的
        const circle = document.getElementById('splitCircle');
        if(circle) circle.classList.remove('focused');

        // 6. 素描模式隱藏對焦框
        if(isSketchMode) { 
            splitCircle.style.display = 'none'; 
            fsGuideFrame.style.display = 'none'; 
        } else { 
            splitCircle.style.display = 'block'; 
            fsGuideFrame.style.display = 'block'; 
        } 
    }

    
  function handleShutter(e) { 
        if(e) e.stopPropagation(); 
        if (e && e.target.id === 'vf-close-btn') return; 
        
        // 檢查條件
        if (!isSelfieMode && backDoorWrapper.classList.contains('open')) return; 
        if (isRollMode && currentFrame >= 36) return; 
        
        const btn = isSelfieMode ? document.getElementById('selfieShutterBtn') : shutterBtn; 
        const circle = document.getElementById('splitCircle');
        
        // --- 時間點 T=0：按下瞬間 ---
        
        // 1. 按鈕視覺下壓
        btn.classList.add('pressed'); 
        
        // 2. [關鍵] 圓圈立刻變綠 (先讓你看見綠圈)
        if(circle) circle.classList.add('focused');

        // --- 時間點 T=0.1秒：執行快門 ---
        setTimeout(() => {
            
            // 3. 播放快門聲
            playShutterSound(); 
            
            // 4. 播放快門簾黑屏/閃光動畫
            if (isSelfieMode) { 
                shutterFlash.classList.remove('flash'); 
                void shutterFlash.offsetWidth; 
                shutterFlash.classList.add('flash'); 
                setTimeout(() => shutterFlash.classList.remove('flash'), 150); 
            } else { 
                const container = (fsViewfinder.style.display === 'block') ? fsViewfinder : vfTrigger; 
                const blind = document.createElement('div'); 
                blind.className = container === fsViewfinder ? 'shutter-blind' : 'vf-shutter-blind'; 
                container.appendChild(blind); 
                setTimeout(() => blind.remove(), 150); 
            } 

            // --- 時間點 T=0.6秒：切換畫面 ---
            // (從快門聲後再等 0.5秒，確保你有足夠時間感受到綠圈與拍照的過程)
            setTimeout(() => { 
                performCapture(); 


             
                // 復原狀態
                btn.classList.remove('pressed'); 

currentRollState = Math.random();
                
                if(circle) circle.classList.remove('focused');
            }, 400);

        }, 100); // <--- 這裡控制「變綠」到「聲音」的 0.1 秒延遲
    }

    function generateLightLeak(ctx, w, h, severity = 1) { ctx.save(); ctx.globalCompositeOperation = 'screen'; const baseCount = severity > 1 ? 3 : (Math.random() > 0.7 ? 2 : 1); for(let i=0; i<baseCount; i++) { const type = Math.random(); const opacity = (0.4 + Math.random() * 0.4) * severity; const hue = Math.random() > 0.8 ? 40 + Math.random()*10 : 10 + Math.random()*30; let colorInner = `hsla(${hue}, 90%, 60%, ${opacity})`; let colorOuter = `hsla(${hue-10}, 90%, 40%, 0)`; if (type < 0.4) { const isLeft = Math.random() > 0.5; const width = w * (0.15 + Math.random() * 0.3); const grad = ctx.createLinearGradient(isLeft ? 0 : w, 0, isLeft ? width : w - width, 0); grad.addColorStop(0, colorInner); grad.addColorStop(1, colorOuter); ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); } else { const cx = Math.random() > 0.5 ? 0 : w; const cy = Math.random() > 0.5 ? 0 : h; const r = Math.max(w, h) * (0.4 + Math.random() * 0.4); const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r); grad.addColorStop(0, `hsla(${hue}, 20%, 90%, ${opacity})`); grad.addColorStop(1, `hsla(${hue}, 90%, 20%, 0)`); ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); } } ctx.restore(); }
        
   async function performCapture() { 
    fsViewfinder.style.display = 'none';
    const modes = getModes(); const mode = modes[currentModeIdx]; 
    const targetW = 1920, targetH = 1080; 
    
    // [關鍵邏輯]
    // 拍攝瞬間，如果模式是 AGED，就強制用它的真實索引 (7) 重新渲染一次高解析度畫面。
    if (mode.idx === 7 && webGLRenderer) {
        // 確保 processCanvas 尺寸足夠大以輸出高畫質照片
        if (processCanvas.width !== targetW || processCanvas.height !== targetH) {
            processCanvas.width = targetW;
            processCanvas.height = targetH;
        }
        // 使用索引 7 (AGED) 進行最後的渲染
        webGLRenderer.render(video, 7, isSelfieMode, currentZoom, currentRollState);
    }

    const tempC = document.createElement('canvas');
    tempC.width = targetW; tempC.height = targetH;
    const tempCtx = tempC.getContext('2d');
    tempCtx.filter = 'none'; 
    
    // 從 processCanvas 獲取最終渲染的畫面
    tempCtx.drawImage(processCanvas, 0, 0, targetW, targetH); 
    
    if (mode.id.startsWith('FILM_')) { const severity = (mode.id === 'FILM_AGED') ? 2.0 : 1.0; generateLightLeak(tempCtx, targetW, targetH, severity); } 
    currentReviewCanvas = tempC;

    if (!isRollMode) {
        const previewData = tempC.toDataURL('image/jpeg', 0.9);
        document.getElementById('review-img').src = previewData;
        document.getElementById('review-overlay').style.display = 'flex';
    } else {
        if (exposureCanvas.width !== targetW) { exposureCanvas.width = targetW; exposureCanvas.height = targetH; }
        exposureCtx.globalCompositeOperation = isFilmAdvanced ? 'source-over' : 'screen';
        exposureCtx.drawImage(tempC, 0, 0);
        isFilmAdvanced = false; 
        updateLeverUI();
    }
}
        
    document.getElementById('btn-discard').addEventListener('click', () => { currentReviewCanvas = null; pendingPhoto = null; document.getElementById('review-overlay').style.display = 'none'; }); 
    document.getElementById('btn-keep').addEventListener('click', () => { 
        document.getElementById('review-overlay').style.display = 'none'; 
        if (currentReviewCanvas) {
            const w = currentReviewCanvas.width; const h = currentReviewCanvas.height;
            if (exposureCanvas.width !== w) { exposureCanvas.width = w; exposureCanvas.height = h; }
            if (isFilmAdvanced) { exposureCtx.globalCompositeOperation = 'source-over'; exposureCtx.drawImage(currentReviewCanvas, 0, 0); isFilmAdvanced = false; } 
            else { exposureCtx.globalCompositeOperation = 'screen'; exposureCtx.globalAlpha = 0.8; exposureCtx.drawImage(currentReviewCanvas, 0, 0); exposureCtx.globalAlpha = 1.0; }
            updateLeverUI();
        }
        currentReviewCanvas = null;
    });

    rollModeSwitch.addEventListener('click', async () => { 
        if(pendingPhoto || (isRollMode && currentFrame > 0)) { 
            const msg = isRollMode ? `WARNING:\nSwitching modes will DELETE all ${currentFrame} photos in this roll.\n\nContinue?` : "Discard current photo and switch mode?";
            const userConfirmed = await retroConfirm(msg);
            if(!userConfirmed) return; 
            await clearTemp(); exposureCtx.clearRect(0, 0, exposureCanvas.width, exposureCanvas.height); pendingPhoto = null; isFilmAdvanced = true; 
        } 
        isRollMode = !isRollMode; localStorage.setItem('rollMode', isRollMode); rollModeSwitch.classList.toggle('mode-36', isRollMode); currentFrame = 0; 
        updateCounterDisplay(); if (typeof updateLeverUI === "function") { updateLeverUI(); } else { checkLeverState(); }
    });
        
    let leverPulled = false; 
    advanceLever.addEventListener('click', async () => {
        const isEndOfRoll = isRollMode && currentFrame >= 36;
        if ((isFilmAdvanced && !isEndOfRoll) || leverPulled) return;
        leverPulled = true; playLeverSound();
        requestAnimationFrame(() => { advanceLever.style.transform = 'rotate(130deg)'; }); 
        setTimeout(async () => { 
            advanceLever.style.transform = 'rotate(10deg)'; 
            if (isEndOfRoll) { styleOverlay.style.display = 'flex'; leverPulled = false; return; }
            const finalImage = exposureCanvas.toDataURL('image/jpeg', 0.92);
            if (isRollMode) { await saveToTemp(finalImage); currentFrame++; updateCounterDisplay(); isFilmAdvanced = true; exposureCtx.clearRect(0,0, exposureCanvas.width, exposureCanvas.height); updateLeverUI(); leverPulled = false; } 
            else { styleOverlay.style.display = 'flex'; pendingPhoto = finalImage; leverPulled = false; }
        }, 400); 
    });

    // [新增] 日期開關邏輯
    const dateOptWrapper = document.getElementById('date-option-wrapper');
    const dateCheckbox = document.getElementById('date-checkbox');
    let isDateImprintOn = true; // 預設開啟

    if (dateOptWrapper && dateCheckbox) {
        dateOptWrapper.addEventListener('click', () => {
            isDateImprintOn = !isDateImprintOn;
            if (isDateImprintOn) {
                dateCheckbox.classList.add('checked');
            } else {
                dateCheckbox.classList.remove('checked');
            }
        });
    }

    // [修改] 風格按鈕點擊事件 (加入傳遞 isDateImprintOn)
    document.querySelectorAll('.style-btn').forEach(btn => { 
        btn.addEventListener('click', async (e) => { 
            const style = e.currentTarget.dataset.style; 
            styleOverlay.style.display = 'none'; 
            
            isFilmAdvanced = true; 
            updateLeverUI(); 
            exposureCtx.clearRect(0,0, exposureCanvas.width, exposureCanvas.height);
            
            let photosToProcess = []; 
            if (isRollMode && currentFrame >= 36) { 
                photosToProcess = await getTempPhotos(); 
            } 
            else if (pendingPhoto) { 
                photosToProcess = [{ image: pendingPhoto, date: new Date() }]; 
                pendingPhoto = null; 
            }
            
            if (photosToProcess.length > 0) { 
                fsViewfinder.style.display = 'none'; 
                // [關鍵修改] 呼叫顯影函數時，傳入 isDateImprintOn
                await startDevelopingAnimation(photosToProcess, style, isDateImprintOn); 
            }
        }); 
    });

   // 1. 處理顯示用的最終照片 (修正 Serial 位置)
   // [修改] 增加 showDate 參數，控制是否繪製日期
    function processFinalPhoto(imgUrl, dateObj, serialNo, style, customText, showDate = true) { 
        return new Promise(async (resolve) => { 
            try { await document.fonts.load('600 40px "Noto Serif TC"'); } catch (e) {}
            const img = new Image(); 
            img.onload = () => { 
                let w = 1920, h = 1080; let padTop = 0, padSide = 0, padBottom = 0; 
                // 設定畫布尺寸與邊距
                if (style === 'white') { padTop = 50; padSide = 50; padBottom = 180; w = 1200; h = Math.floor(w * (img.height / img.width)) + padTop + padBottom; } 
                else if (style === 'film') { padTop = 80; padSide = 0; padBottom = 80; w = img.width; h = img.height + padTop + padBottom; } 
                else { w = img.width; h = img.height; }

                finalCanvas.width = w; finalCanvas.height = h; const ctx = finalCanvas.getContext('2d'); ctx.filter = 'none'; 
                
                // 繪製背景與圖片
                if (style === 'white') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h); ctx.drawImage(img, padSide, padTop, w - padSide*2, h - padTop - padBottom); } 
                else if (style === 'film') { ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h); ctx.drawImage(img, 0, padTop, w, img.height); ctx.fillStyle = '#fff'; const holeW = 30, gap = 20; for(let x = 30; x < w; x += (holeW + gap)) { ctx.fillRect(x, 25, holeW, 30); } for(let x = 30; x < w; x += (holeW + gap)) { ctx.fillRect(x, h - 55, holeW, 30); } } 
                else { ctx.drawImage(img, 0, 0, w, h); } 

                // [修改邏輯] 只有當 showDate 為 true 時才繪製日期
                if (showDate) {
                    const d = new Date(dateObj); 
                    const dateStr = `'${d.getFullYear().toString().slice(-2)} ${(d.getMonth()+1).toString().padStart(2,'0')} ${d.getDate().toString().padStart(2,'0')}`; 
                    
                    let dateX = w - 60; let dateY = h - 50;
                    // 日期位置微調
                    if (style === 'white') { dateX = w - padSide - 30; dateY = h - padBottom - 30; } 
                    else if (style === 'film') { dateX = w - 50; dateY = h - padBottom - 40; }

                    if (isSketchMode) { 
                        ctx.save(); ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(50, 50, 50, 0.85)'; ctx.font = `normal 45px "Segoe Print", cursive`; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom'; ctx.translate(dateX, dateY); ctx.rotate(-0.05); ctx.fillText(dateStr, 0, 0); ctx.restore(); 
                    } 
                    else { 
                        ctx.shadowColor = '#ff5500'; ctx.shadowBlur = 15; ctx.fillStyle = 'rgba(255, 170, 50, 0.9)'; 
                        const fontSize = style === 'white' ? 40 : 50; 
                        ctx.font = `bold ${fontSize}px "Courier New", monospace`; 
                        ctx.textAlign = 'right'; ctx.textBaseline = 'bottom'; 
                        ctx.fillText(dateStr, dateX, dateY); 
                    }
                }

                // SERIAL NUMBER 繪製 (保持不變)
                let serX = 30, serY = 70, serColor = 'rgba(255,255,255,0.8)';
                
                if (style === 'white') { 
                    serX = 50; 
                    serY = h - 65; 
                    serColor = '#333'; 
                } else if (style === 'film') { 
                    serX = 40; 
                    serY = h - 80;
                    serColor = 'rgba(255,255,255,0.6)'; 
                }
                
                ctx.shadowColor = style === 'white' ? 'transparent' : '#000'; ctx.shadowBlur = 2; ctx.fillStyle = serColor; ctx.font = `bold 36px "Courier New", monospace`; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; 
                if (serialNo !== "") { ctx.fillText(`No.${serialNo}`, serX, serY); }
                
                // 自定義文字 (Instant Style)
                if (style === 'white' && customText && customText.trim() !== "") { ctx.fillStyle = '#111'; ctx.shadowBlur = 0; ctx.font = `600 38px "Noto Serif TC", serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillText(customText, w / 2, h - 40); }
                
                resolve(finalCanvas.toDataURL('image/jpeg', 0.9)); 
            }; img.src = imgUrl; 
        }); 
    }

    // 2. 處理匯出用的照片 (修正 Serial 位置，確保與預覽一致)
    function annotateExportPhoto(imgUrl, serialNo, style, customText) {
        return new Promise(async (resolve) => {
            try { await document.fonts.load('600 40px "Noto Serif TC"'); } catch (e) {}
            try { await document.fonts.load('bold 36px "Courier New"'); } catch (e) {}
            const img = new Image(); img.onload = () => {
                const w = img.width; const h = img.height; const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0);
                const hasCaption = (customText && customText.trim() !== "");
                
               if (serialNo && serialNo !== "") {
    let serX = 30, serY = 70, serColor = '#fff', useShadow = true; 
                    if (style === 'white') { 
                        if (hasCaption) { 
                            serX = 50; serY = h - 190; serColor = 'rgba(255, 255, 255, 0.9)'; useShadow = true; 
                        } else { 
                            serX = 50; 
                            // [修改] 標準模式無 Caption 時，位置統一為 h - 65
                            serY = h - 65; 
                            serColor = '#333'; useShadow = false; 
                        } 
                    } else if (style === 'film') { 
    serX = 40; 
    serY = h - 80;  // [修改] 改為 h - 80，讓文字更明顯地高於底部齒孔
    serColor = 'rgba(255,255,255,0.6)'; 
}
                    
                    if (useShadow) { ctx.shadowColor = '#000'; ctx.shadowBlur = 4; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; } else { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
                    ctx.fillStyle = serColor; ctx.font = `bold 36px "Courier New", monospace`; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; ctx.fillText(`No.${serialNo}`, serX, serY);
                }
                
                if (style === 'white' && hasCaption) { ctx.fillStyle = '#111'; ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.font = `600 42px "Noto Serif TC", serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillText(customText, w / 2, h - 90); }
                resolve(canvas.toDataURL('image/jpeg', 0.92));
            }; img.src = imgUrl;
        });
    }
        
    // [修改] 接收 wantDate 參數
    async function startDevelopingAnimation(photos, style, wantDate = true) { 
        // 清空輸入框防止殘留
        document.getElementById('exp-text-input').value = "";

        devOverlay.style.display = 'flex'; 
        devStatus.textContent = "PREPARING..."; 
        
        let waterLoopId; let rippleTime = 0; let waveIntensity = 1.0; 
        const turbulenceNode = document.querySelector('#liquidFilter feTurbulence'); 
        const paperContainer = document.querySelector('.photo-paper-container');
        
        function renderWaterRipple() { rippleTime += 0.05; const baseFreqY = (0.05 + Math.sin(rippleTime * 0.5) * 0.01) * waveIntensity; const displayFreq = Math.max(0.001, baseFreqY); turbulenceNode.setAttribute('baseFrequency', `0.01 ${displayFreq}`); waterLoopId = requestAnimationFrame(renderWaterRipple); }

        const processed = []; 
        for (let p of photos) { 
            const thisSerial = globalSerialCounter++; 
            localStorage.setItem('global_serial_counter', globalSerialCounter); 
            
            // [關鍵修改] 呼叫 processFinalPhoto 時，傳入 wantDate 參數 (最後一個參數)
            // 參數順序: imgUrl, dateObj, serialNo, style, customText, showDate
            const finalImg = await processFinalPhoto(p.image, p.date, "", style, "", wantDate); 
            
            processed.push({ img: finalImg, serial: thisSerial, style: style }); 
        }
        
        for (let i = 0; i < processed.length; i++) { 
            devStatus.textContent = `DEVELOPING ${i+1}/${processed.length}`; 
            devImageWrap.src = processed[i].img; 
            devImageWrap.style.border = style === 'white' ? 'none' : '8px solid white'; 
            
            waveIntensity = 1.0; devImageWrap.style.opacity = '0'; devImageWrap.style.filter = 'none'; 
            paperContainer.classList.add('wet-process'); devImageWrap.classList.add('in-liquid');
            renderWaterRipple(); 
            
            devImageWrap.style.animation = 'none'; devImageWrap.offsetHeight; 
            devImageWrap.style.animation = 'developProcess 3s forwards linear'; 
            
            await new Promise(r => setTimeout(r, 2500));
            
            const calmDuration = 800; const startTime = Date.now();
            while (true) { const elapsed = Date.now() - startTime; if (elapsed >= calmDuration) { waveIntensity = 0; break; } const progress = elapsed / calmDuration; waveIntensity = 1.0 - Math.pow(progress, 0.5); await new Promise(r => requestAnimationFrame(r)); }
            
            cancelAnimationFrame(waterLoopId); 
            devImageWrap.style.opacity = '1'; devImageWrap.style.transform = 'scale(1)'; 
            devImageWrap.style.animation = 'none'; devImageWrap.style.filter = 'none'; 
            devImageWrap.classList.remove('in-liquid'); paperContainer.classList.remove('wet-process');
            
            await new Promise(r => setTimeout(r, 1500));
            
            // 存入相冊
            await saveToAlbum(processed[i].img, processed[i].serial, processed[i].style, finalCanvas.width, finalCanvas.height); 
            devImageWrap.style.opacity = '0';
        } 
        
        document.getElementById('exp-text-input').value = ""; 
        
        devStatus.textContent = "FINISHED"; 
        await new Promise(r => setTimeout(r, 800)); 
        devOverlay.style.display = 'none'; 
        
        if (isRollMode) { await clearTemp(); currentFrame = 0; updateCounterDisplay(); } else { pendingPhoto = null; } 
        updateLeverUI(); 
    }

    backLock.addEventListener('click', () => { const isOpen = backDoorWrapper.classList.contains('open'); if (!isOpen) { latchAudio.currentTime = 0; latchAudio.play(); backDoorWrapper.classList.add('open'); backLock.style.transform = 'translateX(5px)'; loadAlbum(); } else { closeBackDoor(); } });
    function closeBackDoor() { backDoorWrapper.classList.remove('open'); backLock.style.transform = 'translateX(0)'; setTimeout(() => { latchAudio.currentTime = 0; latchAudio.play(); }, 250); }
    let selectedAlbumIds = new Set(); let currentAlbumData = [];
    function updateViewVisibility() { if (isFilmViewMode) { albumGrid.classList.remove('active'); filmStripView.classList.add('active'); btnViewFilm.classList.add('active'); btnViewGrid.classList.remove('active'); staticCanister.style.display = 'block'; } else { filmStripView.classList.remove('active'); albumGrid.classList.add('active'); btnViewGrid.classList.add('active'); btnViewFilm.classList.remove('active'); staticCanister.style.display = 'none'; } }
    btnViewFilm.addEventListener('click', () => { isFilmViewMode = true; updateViewVisibility(); });
    btnViewGrid.addEventListener('click', () => { isFilmViewMode = false; updateViewVisibility(); });

    async function loadAlbum() {
        const loader = document.getElementById('album-loader'); const grid = document.getElementById('albumGrid'); const strip = document.getElementById('filmStripView');
        loader.style.display = 'block'; grid.innerHTML = ''; strip.innerHTML = ''; 
        setTimeout(async () => {
            try {
                selectedAlbumIds.clear(); currentAlbumData = await getAlbumPhotos(); currentAlbumData.sort((a,b) => b.timestamp - a.timestamp); 
                if(currentAlbumData.length === 0) { const emptyMsg = '<p style="color:#555; width:100%; text-align:center; margin-top:50px; font-family:monospace;">ALBUM EMPTY</p>'; grid.innerHTML = emptyMsg; strip.innerHTML = emptyMsg; } 
                else {
                    const gridFragment = document.createDocumentFragment(); const stripFragment = document.createDocumentFragment(); const visibleHeight = 152; 
                    const tasks = currentAlbumData.map(p => { if (p.width && p.height && p.width > 0) { const naturalRatio = p.width / p.height; return Promise.resolve({ p: p, width: visibleHeight * naturalRatio }); } return new Promise((resolve) => { const img = new Image(); img.onload = () => { const naturalRatio = img.width / img.height; resolve({ p: p, width: visibleHeight * naturalRatio }); }; img.onerror = () => resolve({ p: p, width: 228 }); img.src = p.image; }); });
                    const processedItems = await Promise.all(tasks);
                    for (const item of processedItems) {
                        const p = item.p;
                        const div = document.createElement('div'); div.className = 'album-photo'; div.dataset.id = p.id; const imgEl = document.createElement('img'); imgEl.src = p.image; imgEl.loading = "lazy"; const seq = document.createElement('div'); seq.className = 'album-seq'; seq.textContent = `No.${p.serial}`; div.appendChild(imgEl); div.appendChild(seq); div.onclick = (e) => { if (div.clickTimeout) { clearTimeout(div.clickTimeout); div.clickTimeout = null; showZoom(p.image); } else { div.clickTimeout = setTimeout(() => { div.clickTimeout = null; toggleSelectionAll(p.id); }, 250); } }; gridFragment.appendChild(div);
                        const frameContainer = document.createElement('div'); frameContainer.className = 'film-frame-container'; frameContainer.dataset.id = p.id; frameContainer.style.width = `${item.width}px`; const block = document.createElement('div'); block.className = 'film-block'; const blockImg = document.createElement('div'); blockImg.className = 'film-block-img'; blockImg.style.backgroundImage = `url(${p.image})`; const meta = document.createElement('div'); meta.className = 'film-meta-label'; meta.textContent = `No.${p.serial}`; block.appendChild(blockImg); block.appendChild(meta); frameContainer.appendChild(block); frameContainer.onclick = (e) => { frameContainer.scrollIntoView({behavior: "smooth", block: "center", inline: "center"}); if (frameContainer.clickTimeout) { clearTimeout(frameContainer.clickTimeout); frameContainer.clickTimeout = null; showZoom(p.image); } else { frameContainer.clickTimeout = setTimeout(() => { frameContainer.clickTimeout = null; toggleSelectionAll(p.id); }, 250); } }; stripFragment.appendChild(frameContainer);
                    }
                    grid.appendChild(gridFragment); strip.appendChild(stripFragment);
                }
                updateViewVisibility();
            } catch (err) { console.error("Album Load Error", err); } finally { loader.style.display = 'none'; }
        }, 50);
    }
        
    function showZoom(imgSrc) { zoomImg.src = imgSrc; zoomOverlay.classList.add('active'); }
    zoomOverlay.addEventListener('click', () => { zoomOverlay.classList.remove('active'); });
    function toggleSelectionAll(id) { if (selectedAlbumIds.has(id)) { selectedAlbumIds.delete(id); } else { selectedAlbumIds.add(id); } syncSelectionUI(); }
    function syncSelectionUI() { document.querySelectorAll('.album-photo').forEach(el => { const pid = parseInt(el.dataset.id); if(selectedAlbumIds.has(pid)) el.classList.add('selected'); else el.classList.remove('selected'); }); document.querySelectorAll('.film-frame-container').forEach(el => { const pid = parseInt(el.dataset.id); if(selectedAlbumIds.has(pid)) el.classList.add('selected'); else el.classList.remove('selected'); }); }
    document.getElementById('alb-sel-all').addEventListener('click', () => { const allSelected = selectedAlbumIds.size === currentAlbumData.length; if (allSelected) selectedAlbumIds.clear(); else currentAlbumData.forEach(p => selectedAlbumIds.add(p.id)); syncSelectionUI(); });
    document.getElementById('alb-delete').addEventListener('click', async () => { if (!checkSelection()) { retroAlert("SELECT PHOTOS FIRST"); return; } const userConfirmed = await retroConfirm("DELETE SELECTED PHOTOS?\n(Cannot be undone)"); if (userConfirmed) { const idsToRemove = Array.from(selectedAlbumIds); await deleteFromAlbum(idsToRemove); await loadAlbum(); } });
    
    const exportModal = document.getElementById('export-modal'); let exportActionType = ''; 
    function checkSelection() { if (selectedAlbumIds.size === 0) return false; return true; }
     document.getElementById('alb-download').addEventListener('click', () => { 
        if(!checkSelection()) { 
            retroAlert("SELECT PHOTOS FIRST"); 
            return; 
        } 
        
        exportActionType = 'download'; 
        
        // 獲取輸入框元素
        const inputEl = document.getElementById('exp-text-input');
        
        // [修訂] 強制隱藏 CAPTION 輸入框並清空內容，不再判斷風格
        inputEl.value = ""; 
        inputEl.style.display = 'none';  
        
        exportModal.style.display = 'flex'; 
    });

    // [修改] 分享按鈕監聽器：加入同樣的檢查邏輯
    document.getElementById('alb-share').addEventListener('click', () => { 
        if(!checkSelection()) { 
            retroAlert("SELECT PHOTOS FIRST"); 
            return; 
        } 
        
        if(!navigator.share) { 
            retroAlert("SHARING NOT SUPPORTED"); 
            return; 
        } 
        
        exportActionType = 'share'; 
        
        // 獲取輸入框元素
        const inputEl = document.getElementById('exp-text-input');
        
        // [修訂] 強制隱藏 CAPTION 輸入框並清空內容，不再判斷風格
        inputEl.value = ""; 
        inputEl.style.display = 'none';  
        
        exportModal.style.display = 'flex'; 
    });
     document.getElementById('exp-cancel').addEventListener('click', () => {
        document.getElementById('exp-text-input').value = "";
        exportModal.style.display = 'none';
    });
    document.getElementById('exp-no-serial').addEventListener('click', () => processExport(false));
    document.getElementById('exp-with-serial').addEventListener('click', () => processExport(true));
   async function processExport(addSerial) { 
        const inputEl = document.getElementById('exp-text-input');
        const customText = inputEl.value; // 讀取當前輸入的文字
        
        const selectedData = currentAlbumData.filter(p => selectedAlbumIds.has(p.id)); 
        const filesToShare = []; 
        document.body.style.cursor = 'wait';
        
        try {
            for (let p of selectedData) { 
                // 這裡會將你的 Caption 合成到原本乾淨的照片上
                const finalDataUrl = await annotateExportPhoto(p.image, addSerial ? p.serial : "", p.style, customText); 
                const fileName = `RETRO_${Date.now()}_${p.serial}.jpg`; 
                
                if (exportActionType === 'download') { 
                    const link = document.createElement('a'); link.download = fileName; link.href = finalDataUrl; link.click(); await new Promise(r => setTimeout(r, 200)); 
                } 
                else { 
                    const blob = await (await fetch(finalDataUrl)).blob(); filesToShare.push(new File([blob], fileName, { type: 'image/jpeg' })); 
                } 
            } 
            
            if (exportActionType === 'share' && filesToShare.length > 0) { 
                try { await navigator.share({ files: filesToShare }); } catch (e) {} 
            } 
            
            const idsToRemove = selectedData.map(p => p.id); 
            await deleteFromAlbum(idsToRemove); 
            await loadAlbum(); 
            
            // [修正] 匯出完成後，清空輸入框，避免下次誤用
            inputEl.value = "";
            
            resetToCameraUI(); 
        } catch (err) { 
            console.error("Export failed:", err); 
            retroAlert("EXPORT ERROR\nCheck console for details"); 
        } finally { 
            document.body.style.cursor = 'default'; 
        }
    }
    function resetToCameraUI() { exportModal.style.display = 'none'; closeBackDoor(); document.getElementById('review-overlay').style.display = 'none'; pendingPhoto = null; updateLeverUI(); }
    function checkOrientation() { if (window.innerHeight > window.innerWidth) { document.getElementById('orientation-lock').style.display = 'flex'; document.getElementById('camera-container').style.display = 'none'; fsPrompt.style.display = 'none'; } else { document.getElementById('orientation-lock').style.display = 'none'; if (document.fullscreenElement) { document.getElementById('camera-container').style.display = 'block'; document.getElementById('fullscreen-prompt').style.display = 'none'; resizeElements(); } else { enforceFullscreen(); } } }
    function resizeElements() { const container = document.getElementById('camera-container'); const w = window.innerWidth; const h = window.innerHeight; const baseW = 760; const baseH = 420; const isTablet = (w / h) < 1.6; const multiplier = isTablet ? 0.8 : 0.85; const scale = Math.min(w / baseW, h / baseH) * multiplier; container.style.top = '53%'; container.style.left = '50%'; container.style.transform = `translate(-50%, -50%) scale(${scale})`; if (document.fullscreenElement || window.innerHeight < window.innerWidth) { container.style.display = 'block'; } }
   window.addEventListener('resize', () => { 
    checkOrientation(); 
    resizeElements(); 
    updateFSGuideFrame(); // 加入這一行，旋轉手機時白框會自動修正
    setTimeout(() => {
        resizeElements();
        updateFSGuideFrame(); // 延遲再執行一次確保準確
    }, 300); 
});


// 1. 真實電量系統
async function initBatterySystem() {
    const battLevel = document.querySelector('.batt-level');
    const battIcon = document.querySelector('.batt-icon');
    
    if (navigator.getBattery) {
        // 支援 API (Android, PC)
        try {
            const battery = await navigator.getBattery();
            
            const updateBatt = () => {
                // 轉換為百分比寬度 (0.0 - 1.0)
                battLevel.style.width = (battery.level * 100) + '%';
                
                // 充電中顯示綠色/黃色提示
                if(battery.charging) {
                    battIcon.style.borderColor = '#ffff00'; // 充電變黃
                    battLevel.style.backgroundColor = '#ffff00';
                } else {
                    battIcon.style.borderColor = ''; // 恢復原色
                    battLevel.style.backgroundColor = '';
                }
            };
            
            // 初始執行與監聽
            updateBatt();
            battery.addEventListener('levelchange', updateBatt);
            battery.addEventListener('chargingchange', updateBatt);
            
        } catch (e) {
            console.log("Battery API Error", e);
        }
    } else {
        // 不支援 API (iOS Safari) - 保持預設 CSS 動畫或設為滿電
        // 這裡我們讓它顯示 85% 假裝一下，避免空的
        if(battLevel) battLevel.style.width = '85%';
    }
}

/* --- [新增] 全域曝光變數與重置函數 --- */
let currentEV = 0; 
const STEP_EV = 0.5; // 每次點擊移動 0.5 EV (半格)
const MAX_EV = 2.0;  // 最大 +2
const MIN_EV = -2.0; // 最小 -2

/* --- [重置函數] --- */
function resetExposure() {
    currentEV = 0;
    const needle = document.getElementById('exp-needle');
    if(needle) needle.style.left = '50%'; // 回到正中間
    
    if (video.srcObject) {
        video.style.filter = 'brightness(100%)';
        const track = video.srcObject.getVideoTracks()[0];
        const capabilities = track.getCapabilities ? track.getCapabilities() : {};
        if (capabilities.exposureCompensation) {
            track.applyConstraints({ advanced: [{ exposureCompensation: 0 }] }).catch(()=>{});
        }
    }
}

/* --- [曝光控制函數] --- */
async function initExposureControl() {
    const btnPlus = document.getElementById('exp-btn-plus');
    const btnMinus = document.getElementById('exp-btn-minus');
    const needle = document.getElementById('exp-needle');

    if (!btnPlus || !btnMinus || !needle) return;

    // 移除舊監聽器
    const newPlus = btnPlus.cloneNode(true);
    const newMinus = btnMinus.cloneNode(true);
    btnPlus.parentNode.replaceChild(newPlus, btnPlus);
    btnMinus.parentNode.replaceChild(newMinus, btnMinus);

    const applyExposure = async (direction) => {
        // 1. 計算數值
        if (direction === 'up') currentEV = Math.min(currentEV + STEP_EV, MAX_EV);
        else currentEV = Math.max(currentEV - STEP_EV, MIN_EV);

        // 2. 移動指針 (完全數學對應，不會亂跳)
        // -2 EV = 10% (左邊)
        //  0 EV = 50% (中間)
        // +2 EV = 90% (右邊)
        const needlePos = 50 + (currentEV * 20); 
        needle.style.left = needlePos + '%';
        
        // 3. 執行曝光調整
        if (video.srcObject) {
            const track = video.srcObject.getVideoTracks()[0];
            const capabilities = track.getCapabilities ? track.getCapabilities() : {};

            if (capabilities.exposureCompensation) {
                try {
                    await track.applyConstraints({
                        advanced: [{ exposureCompensation: currentEV }]
                    });
                } catch (err) { console.warn("EV error", err); }
            } else {
                // iOS 模擬亮度
                const brightness = 1 + (currentEV * 0.2); 
                video.style.filter = `brightness(${brightness})`;
            }
        }
    };

    newPlus.addEventListener('click', (e) => { e.stopPropagation(); e.preventDefault(); applyExposure('up'); });
    newMinus.addEventListener('click', (e) => { e.stopPropagation(); e.preventDefault(); applyExposure('down'); });
}

// 初始啟動
initBatterySystem();

    

function updateFSGuideFrame() {
    const container = document.getElementById('fs-viewfinder');
    if (container.style.display !== 'block') return;

    const canvas = document.getElementById('process-canvas'); // 這是我們的源頭尺寸
    const frame = document.getElementById('fsGuideFrame');
    
    // 取得當前畫面比例 (通常是 16:9)
    const imgAspect = canvas.width / canvas.height;
    const winAspect = window.innerWidth / window.innerHeight;
    
    let actualImgW, actualImgH;

    if (winAspect > imgAspect) {
        // 螢幕比照片寬 (左右有黑邊) -> 照片高度等於螢幕高度
        actualImgH = window.innerHeight;
        actualImgW = actualImgH * imgAspect;
    } else {
        // 螢幕比照片高 (上下有黑邊) -> 照片寬度等於螢幕寬度
        actualImgW = window.innerWidth;
        actualImgH = actualImgW / imgAspect;
    }

    // 設定白框大小為實際照片範圍的 85%
    frame.style.width = (actualImgW * 0.85) + 'px';
    frame.style.height = (actualImgH * 0.85) + 'px';
}

    
</script>
</body>
</html>
